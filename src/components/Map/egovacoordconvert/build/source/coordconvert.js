(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["CoordConvert"] = factory();
	else
		root["CoordConvert"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./egova/coordconvert/CoordConvert.js":
/*!*********************************************************!*\
  !*** ./egova/coordconvert/CoordConvert.js + 42 modules ***!
  \*********************************************************/
/*! exports provided: ConvertType, getConvertFactory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("\n// CONCATENATED MODULE: ./egova/coordconvert/CoordConvertType.js\n/**\r\n * 涉及七类坐标系之间的坐标互相转换\r\n * 1）WGS84经纬度，即手机GPS的坐标，等效于CGCJ2000经纬度，天地图采用\r\n * 2）WGS84墨卡托投影平面，即WGS84经纬度或CGCJ2000经纬度做Web墨卡托投影得到的平面坐标，天地图采用\r\n * 3）GCJ02经纬度，即国测局火星坐标系，高德地图、腾讯地图、谷歌地图采用\r\n * 4）GCJ02平面，即GCJ02经纬度做Web墨卡托投影得到的平面坐标，高德地图、腾讯地图、谷歌地图采用\r\n * 5）百度经纬度，即百度的BD09坐标系，是在GCJ02坐标系上坐标了二次脱密得到，百度地图采用\r\n * 6）百度平面，即百度经纬度做特殊的投影得到的平面坐标，百度地图采用\r\n * 7）城市平面，即各个城市或地区所采用的地方独立坐标系\r\n */\nvar CoordConvertType = {\n  //**********WGS84经纬度转其他**********\n  //****WGS84经纬度转城市平面的细分类型****\n  /**\r\n   * BJ54城市坐标（7参数）\r\n   */\n  SERVEN_BJ54: \"7BJ54\",\n  /**\r\n   *  西安80城市坐标（7参数）\r\n   */\n  SERVEN_XA80: \"7XA80\",\n  /**\r\n   * WGS84（7参数）\r\n   */\n  SERVEN_WGS84: \"7WGS84\",\n  /**\r\n   * 北京54(4参数)\r\n   */\n  FOUR_BJ54: \"BJ54\",\n  /**\r\n   * 西安80(4参数)\r\n   */\n  FOUR_XA80: \"XA80\",\n  /**\r\n   * WGS84（4参数）\r\n   */\n  FOUR_WGS84: \"WGS84\",\n  /**\r\n   * 移动测量\r\n   */\n  YDCL: \"YDCL\",\n  /**\r\n   * GPS\r\n   */\n  GPS: \"GPS\",\n  /**\r\n   * 默认的也即GPS方式\r\n   */\n  NULL: \"NULL\",\n  /**\r\n   * 经纬度转WEB墨卡托\r\n   */\n  MKT: \"MKT\",\n  //**********2018年10月兼容手机端而扩展**********\n  BJCG: \"BJCG\", //北京城管\n  HZCG: \"HZCG\", //杭州城管\n  WLMQKFQ: \"WLMQKFQ\", //乌鲁木齐开发区城管\n  FZCG: \"FZCG\", //福州城管\n  CSCG: \"CSCG\", //长沙城管\n  LZCG: \"LZCG\", //兰州城管\n  SYCG: \"SYCG\", //沈阳城管\n  BD: \"BD\", //百度地图\n  GD: \"GD\", //高德地图\n\n  //****WGS84经纬度转其他类型****\n  WGS84LL_TO_WGS84MC: \"84ll284mc\", //WGS84经纬度转WGS84墨卡托投影平面\n  WGS84LL_TO_GCJ02LL: \"84ll2gcjll\", //WGS84经纬度转GCJ02经纬度\n  //WGS84LL_TO_GCJ02MC:\"84ll2gcjmc\",//WGS84经纬度转GCJ02平面\n  WGS84LL_TO_BDLL: \"84ll2bdll\", //WGS84经纬度转百度经纬度\n  //WGS84LL_TO_BDMC:\"84ll2bdmc\",//WGS84经纬度转百度平面\n  WGS84LL_TO_CITY: \"84ll2xy\", //WGS84经纬度转城市平面\n\n  //**********WGS84-web墨卡托投影平面（天地图平面）到其他**********\n  WGS84MC_TO_WGS84LL: \"84mc284ll\", //WGS84墨卡托投影平面转WGS84经纬度\n  //WGS84MC_TO_GCJ02LL:\"84mc2gcjll\",//WGS84墨卡托投影平面转GCJ02经纬度\n  //WGS84MC_TO_GCJ02MC:\"84mc2gcjmc\",//WGS84墨卡托投影平面转GCJ02平面\n  //WGS84MC_TO_BDLL:\"84mc2bdll\",//WGS84墨卡托投影平面转百度经纬度\n  //WGS84MC_TO_BDMC:\"84mc2bdmc\",//WGS84墨卡托投影平面转百度平面\n  //WGS84MC_TO_CITY:\"84mc2xy\",//WGS84墨卡托投影平面转城市平面\n\n  //**********GCJ02（高德|腾讯|谷歌）经纬度到其他**********\n  GCJ02LL_TO_WGS84LL: \"gcjll284ll\", //GCJ02经纬度转WGS84经纬度\n  //GCJ02LL_TO_WGS84MC:\"gcjll284mc\",//GCJ02经纬度转WGS84墨卡托投影平面\n  GCJ02LL_TO_GCJ02MC: \"gcjll2gcjmc\", //GCJ02经纬度转GCJ02平面\n  GCJ02LL_TO_BDLL: \"gcjll2bdll\", //GCJ02经纬度转百度经纬度\n  //GCJ02LL_TO_BDMC:\"gcjll2bdmc\",//GCJ02经纬度转百度平面\n  //GCJ02LL_TO_CITY:\"gcjll2xy\",//GCJ02经纬度转城市平面\n\n  //**********GCJ02（高德|腾讯|谷歌）平面到其他**********\n  //GCJ02MC_TO_WGS84LL:\"gcjmc284ll\",//GCJ02平面转WGS84经纬度\n  //GCJ02MC_TO_WGS84MC:\"gcjmc284mc\",//GCJ02平面转WGS84墨卡托投影平面\n  GCJ02MC_TO_GCJ02LL: \"gcjmc2gcjll\", //GCJ02平面转GCJ02经纬度\n  //GCJ02MC_TO_BDLL:\"gcjmc2bdll\",//GCJ02平面转百度经纬度\n  //GCJ02MC_TO_BDMC:\"gcjmc2bdmc\",//GCJ02平面转百度平面\n  //GCJ02MC_TO_CITY:\"gcjmc2xy\",//GCJ02平面转城市平面\n\n  //**********百度经纬度到其他**********\n  BDLL_TO_WGS84LL: \"bdll284ll\", //百度经纬度转WGS84经纬度\n  //BDLL_TO_WGS84MC:\"bdll284mc\",//百度经纬度转WGS84墨卡托投影平面\n  BDLL_TO_GCJ02LL: \"bdll2gcjll\", //百度经纬度转GCJ02经纬度\n  //BDLL_TO_GCJ02MC:\"bdll2gcjmc\",//百度经纬度转GCJ02平面\n  BDLL_TO_BDMC: \"bdll2bdmc\", //百度经纬度转百度平面\n  //BDLL_TO_CITY:\"bdll2xy\",//百度经纬度转城市平面\n\n  //**********百度平面到其他**********\n  //BDMC_TO_WGS84LL:\"bdmc284ll\",//百度平面转WGS84经纬度\n  //BDMC_TO_WGS84MC:\"bdmc284mc\",//百度平面转WGS84墨卡托投影平面\n  //BDMC_TO_GCJ02LL:\"bdmc2gcjll\",//百度平面转GCJ02经纬度\n  //BDMC_TO_GCJ02MC:\"bdmc2gcjmc\",//百度平面转GCJ02平面\n  BDMC_TO_BDLL: \"bdmc2bdll\", //百度平面转百度经纬度\n  //BDMC_TO_CITY:\"bdmc2xy\",//百度平面转城市平面\n\n  //**********城市（当地）平面到其他**********\n  CITY_TO_WGS84LL: \"xy284ll\", //城市平面转WGS84经纬度\n  //CITY_TO_WGS84MC:\"xy284mc\",//城市平面转WGS84墨卡托投影平面\n  //CITY_TO_GCJ02LL:\"xy2gcjll\",//城市平面转GCJ02经纬度\n  //CITY_TO_GCJ02MC:\"xy2gcjmc\",//城市平面转GCJ02平面\n  //CITY_TO_BDLL:\"xy2bdll\",//城市平面转百度经纬度\n  //CITY_TO_BDMC:\"xy2bdmc\",//城市平面转百度平面\n  /**\r\n  * 北京城管转84经纬度\r\n   */\n  BJCG_TO_WGS84LL: \"BJCG2WGS84\",\n\n  //**********其他**********\n  /**\r\n   * 6参数转换\r\n   */\n  SIX_PARAMS: \"6parms\"\n};\n/* harmony default export */ var coordconvert_CoordConvertType = (CoordConvertType);\n// CONCATENATED MODULE: ./egova/coordconvert/CoordConvertFactory.js\nvar CoordConvertFactory = {};\n/* harmony default export */ var coordconvert_CoordConvertFactory = (CoordConvertFactory);\n// CONCATENATED MODULE: ./egova/coordconvert/converttype/Base.js\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Base = function () {\n  function Base(params) {\n    _classCallCheck(this, Base);\n\n    this.params = params;\n  }\n\n  /**\r\n   * ��������Ե�����ת��\r\n   * @param x �����Ȼ�ƽ��x\r\n   * @param y ����γ�Ȼ�ƽ��y\r\n   */\n\n\n  _createClass(Base, [{\n    key: \"convert\",\n    value: function convert(x, y) {}\n\n    /**\r\n     * �������Ե�����ת��\r\n     * @param coords ��������飬����Ԫ��Ϊһ�������[x,y]��Ҳ��һ����ά����\r\n     */\n\n  }, {\n    key: \"multiConvert\",\n    value: function multiConvert(coords) {\n      if (!Array.isArray(coords) || coords.length == 0) {\n        return null;\n      }\n      var result = [];\n      for (var i = 0; i < coords.length; i++) {\n        var coord = coords[i];\n        var convertedCoord = this.convert(coord[0], coord[1]);\n        result.push(convertedCoord);\n      }\n      return result;\n    }\n  }]);\n\n  return Base;\n}();\n\n/* harmony default export */ var converttype_Base = (Base);\n// CONCATENATED MODULE: ./egova/coordconvert/converttype/Param7.js\nvar Param7_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction Param7_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Param7 = function () {\n    /**\r\n     * 7参数转换构造函数\r\n     * @param sysID 坐标系表示。0:北京五四；1:西安80。目前只支持这两种\r\n     * @param params\r\n     */\n    function Param7(sysID, params) {\n        Param7_classCallCheck(this, Param7);\n\n        this.val1 = 0;\n        this.val2 = 0;\n        this.val3 = 0;\n        //7参数\n        this.r = [0, 0, 0, 0, 0, 0, 0]; //[X平移,Y平移,Z平移,X旋转,Y旋转,Z旋转,以及尺度比参数]\n        //4参数\n        this.DX = 0;\n        this.DY = 0;\n        this.T = 0;\n        this.K = 1;\n        this.L0 = 0; //中央经度，弧度\n        //是否需要X与Y对调\n        this.isXYChange = false;\n        this.e2 = 0;\n        this.a = 0;\n        this.coordType = 0;\n        this.CoordConst = {\n            P_2: 3600 * 180 / Math.PI,\n            CoordType_WGS84: 1,\n            WGS84_A: 6378137.0000000000,\n            WGS84_E2: 0.0066943799013,\n            CoordType_BJ54: 2,\n            BJ54_A: 6378245.0000000000,\n            BJ54_E2: 0.006693421622966,\n            CoordType_C80: 3,\n            C80_A: 6378140.0000000000,\n            C80_E2: 0.006694384999588\n        };\n\n        if (sysID >= 1 && sysID <= 3) {\n            this.coordType = sysID;\n        }\n\n        var x0, y0, z0, rx0, ry0, rz0, m;\n        if (params) {\n            var ps = params.split(\"@\");\n            //7参数\n            if (ps.length >= 1) {\n                var pams = ps[0].split(\"#\");\n                x0 = parseFloat(pams[0].trim());\n                y0 = parseFloat(pams[1].trim());\n                z0 = parseFloat(pams[2].trim());\n                rx0 = parseFloat(pams[3].trim());\n                ry0 = parseFloat(pams[4].trim());\n                rz0 = parseFloat(pams[5].trim());\n                m = parseFloat(pams[6].trim());\n                var rr = [x0, y0, z0, rx0, ry0, rz0, m];\n                this.r = rr;\n            } else {\n                console.log(\"params 7 is null\");\n            }\n\n            //4参数\n            if (ps.length >= 2) {\n                var pams = ps[1].split(\"#\");\n                if (pams.length == 1) {\n                    if (pams[0].trim() == \"1\") this.isXYChange = true;\n                } else {\n                    this.DX = parseFloat(pams[0].trim());\n                    this.DY = parseFloat(pams[1].trim());\n                    this.T = parseFloat(pams[2].trim()); /// 180 * Math.PI;\n                    this.K = parseFloat(pams[3].trim());\n                    if (pams.length >= 5) {\n                        if (pams[4].trim() == \"1\") this.isXYChange = true;\n                    }\n                    if (pams.length >= 6) {\n                        this.L0 = parseFloat(pams[5].trim()) / 180 * Math.PI;\n                    }\n                }\n            } else {\n                console.log(\"params 4 is null\");\n            }\n        } else {\n            console.log(\"params 7 is null\");\n        }\n    }\n\n    Param7_createClass(Param7, [{\n        key: \"convert\",\n        value: function convert(lValue, bValue) {\n            this.val1 = bValue;\n            this.val2 = lValue;\n            this.val3 = 0;\n            //7参数转换\n            this.doConvert();\n            var resX = -1,\n                resY = -1;\n            resX = this.val1;\n            resY = this.val2;\n            //4参数转换\n            var coord = this.trans(resX, resY);\n            return coord;\n        }\n\n        /**\r\n         * 四参数的转换\r\n         * @return\r\n         */\n\n    }, {\n        key: \"trans\",\n        value: function trans(x, y) {\n            var result = new Array(2);\n            if (this.isXYChange) {\n                //按现场实际情况，对调xy坐标\n                result[1] = this.DX + this.K * (x * Math.cos(this.T) - y * Math.sin(this.T));\n                result[0] = this.DY + this.K * (x * Math.sin(this.T) + y * Math.cos(this.T));\n            } else {\n                result[0] = this.DX + this.K * (x * Math.cos(this.T) - y * Math.sin(this.T));\n                result[1] = this.DY + this.K * (x * Math.sin(this.T) + y * Math.cos(this.T));\n            }\n            return result;\n        }\n\n        /**\r\n         * 设置坐标类型\r\n         * @param coordType 1:WGS84 2:BJ54 3:C80\r\n         */\n\n    }, {\n        key: \"setCoordType\",\n        value: function setCoordType(coordType) {\n            switch (coordType) {\n                case this.CoordConst.CoordType_WGS84:\n                    this.e2 = this.CoordConst.WGS84_E2;\n                    this.a = this.CoordConst.WGS84_A;\n                    break;\n                case this.CoordConst.CoordType_BJ54:\n                    this.e2 = this.CoordConst.BJ54_E2;\n                    this.a = this.CoordConst.BJ54_A;\n                    break;\n                case this.CoordConst.CoordType_C80:\n                    this.e2 = this.CoordConst.C80_E2;\n                    this.a = this.CoordConst.C80_A;\n                    break;\n            }\n        }\n\n        /**\r\n         * 获取3度带中央子午线\r\n         * @return\r\n         */\n\n    }, {\n        key: \"getMeridian\",\n        value: function getMeridian() {\n            if (this.val2 < 0) {\n                return -1;\n            }\n            var L1 = this.val2 * 180 / Math.PI;\n            var L2 = parseInt(L1);\n            var left = L1 - L2;\n            var num = parseInt(L2 / 3);\n            left += L2 % 3;\n            if (left >= 1.5) num++;\n            return num * 3;\n        }\n    }, {\n        key: \"space2Space\",\n        value: function space2Space(r) {\n            var X = this.val1;\n            var Y = this.val2;\n            var Z = this.val3;\n            this.val1 = (1 + r[6]) * X + (r[5] * Y - r[4] * Z) + r[0];\n            this.val2 = (1 + r[6]) * Y + (-r[5] * X + r[3] * Z) + r[1];\n            this.val3 = (1 + r[6]) * Z + (r[4] * X - r[3] * Y) + r[2];\n        }\n\n        /**\r\n         * 大地坐标转空间坐标\r\n         * BLH->XYZ\r\n         */\n\n    }, {\n        key: \"earth2Space\",\n        value: function earth2Space() {\n            var B = this.val1;\n            var L = this.val2;\n            var H = this.val3;\n            var W = Math.sqrt(1 - this.e2 * Math.sin(B) * Math.sin(B));\n            var N = this.a / W;\n            this.val1 = (N + H) * Math.cos(B) * Math.cos(L);\n            this.val2 = (N + H) * Math.cos(B) * Math.sin(L);\n            this.val3 = (N * (1 - this.e2) + H) * Math.sin(B);\n        }\n\n        /**\r\n         * XYZ->BLH\r\n         *\r\n         */\n\n    }, {\n        key: \"space2Earth\",\n        value: function space2Earth() {\n            var W = Math.sqrt(1 - this.e2 * Math.sin(this.val1) * Math.sin(this.val1));\n            var N = this.a / W;\n            var X = this.val1;\n            var Y = this.val2;\n            var Z = this.val3;\n            var m;\n            m = Math.sqrt(Math.pow(X, 2) + Math.pow(Y, 2));\n            this.val2 = Math.atan(Y / X);\n            if (this.val2 < 0) this.val2 += Math.PI;\n            var e2_ = this.e2 / (1 - this.e2);\n            var c = this.a * Math.sqrt(1 + e2_);\n            var ce2 = c * this.e2;\n            var k = 1 + e2_;\n            var front = Z / m;\n            var temp = front;\n            var count = 0;\n            do {\n                front = temp;\n                m = Math.sqrt(Math.pow(X, 2) + Math.pow(Y, 2));\n                temp = Z / m + ce2 * front / (m * Math.sqrt(k + Math.pow(front, 2)));\n                count++;\n            } while (Math.abs(temp - front) > Math.tan(0.0001 * Math.PI / (3600 * 180)) && count < 100000); //是否在允许误差内\n            this.val1 = Math.atan(temp);\n            if (this.val1 < 0) this.val1 += Math.PI;\n            W = Math.sqrt(1 - this.e2 * Math.sin(this.val1) * Math.sin(this.val1));\n            N = this.a / W;\n            this.val3 = m / Math.cos(this.val1) - N;\n        }\n\n        /**\r\n         * BLH高斯投影\r\n         * @param dL0\r\n         */\n\n    }, {\n        key: \"earth2Gauss\",\n        value: function earth2Gauss(dL0) {\n            var B = this.val1;\n            var L = this.val2;\n            var l = L - dL0;\n            var B_2 = this.radian2Second(B);\n            var CB2 = Math.cos(B) * Math.cos(B);\n            var l2 = l * l;\n            var N = 6399698.902 - (21562.267 - (108.973 - 0.612 * CB2) * CB2) * CB2;\n            var a0 = 32140.404 - (135.3302 - (0.7092 - 0.0040 * CB2) * CB2) * CB2;\n            var a4 = (0.25 + 0.00252 * CB2) * CB2 - 0.04166;\n            var a6 = (0.166 * CB2 - 0.084) * CB2;\n            var a3 = (0.3333333 + 0.001123 * CB2) * CB2 - 0.1666667;\n            var a5 = 0.0083 - (0.1667 - (0.1968 + 0.004 * CB2) * CB2) * CB2;\n            this.val1 = 6367558.4969 * B_2 / this.CoordConst.P_2 - (a0 - (0.5 + (a4 + a6 * l2) * l2) * l2 * N) * Math.sin(B) * Math.cos(B);\n            this.val2 = (1 + (a3 + a5 * l2) * l2) * l * N * Math.cos(B);\n            this.val2 += 500000;\n        }\n\n        /**\r\n         * 高斯投影到地理坐标\r\n         * @param dL0\r\n         */\n\n    }, {\n        key: \"gauss2Earth\",\n        value: function gauss2Earth(dL0) {\n            this.val2 -= 500000;\n            var x = this.val1;\n            var y = this.val2;\n            var b = x / 6367558.4969;\n            var b_2 = b * 180 * 3600 / Math.PI; //b_2以秒为单位\n            var Cb2 = Math.cos(b) * Math.cos(b);\n            var Bf_2 = b_2 + (50221746 + (293622 + (2350 + 22 * Cb2) * Cb2) * Cb2) * Math.pow(10, -10) * Math.sin(b) * Math.cos(b) * this.CoordConst.P_2;\n            var Bf = Bf_2 * Math.PI / (180 * 3600);\n            var CBf2 = Math.cos(Bf) * Math.cos(Bf);\n            var Nf = 6399698.902 - (21562.267 - (108.973 - 0.612 * CBf2) * CBf2) * CBf2;\n            var Z = y / (Nf * Math.cos(Bf));\n            var b2 = (0.5 + 0.003369 * CBf2) * Math.sin(Bf) * Math.cos(Bf);\n            var b3 = 0.333333 - (0.166667 - 0.00123 * CBf2) * CBf2;\n            var b4 = 0.25 + (0.16161 + 0.00562 * CBf2) * CBf2;\n            var b5 = 0.2 - (0.1667 - 0.0088 * CBf2) * CBf2;\n            var Z2 = Z * Z;\n            this.val1 = Bf_2 - (1 - (b4 - 0.12 * Z2) * Z2) * Z2 * b2 * this.CoordConst.P_2;\n            this.val1 = this.val1 * Math.PI / (180 * 3600);\n            var l = (1 - (b3 - b5 * Z2) * Z2) * Z * this.CoordConst.P_2;\n            l = l * Math.PI / (180 * 3600);\n            this.val2 = dL0 + l;\n        }\n\n        /**\r\n         * 弧度到秒\r\n         * @param r\r\n         * @return\r\n         */\n\n    }, {\n        key: \"radian2Second\",\n        value: function radian2Second(r) {\n            return r * 3600 * 180 / Math.PI;\n        }\n\n        /**\r\n         * 弧度到度分秒\r\n         * @param r\r\n         * @return\r\n         */\n\n    }, {\n        key: \"radian2DMS\",\n        value: function radian2DMS(r) {\n            var t = r * 180 / Math.PI;\n            var d = parseInt(t);\n            var m = parseInt((t - d) * 60);\n            var s = ((t - d) * 60 - m) * 60;\n            if (60.0 - s < 0.01) {\n                s = 0.0;\n                m++;\n                if (m == 60) {\n                    d++;\n                    m = 0;\n                }\n            }\n            return parseFloat(d) + parseFloat(m) * 0.01 + parseFloat(s) * 0.0001;\n        }\n\n        /**\r\n         * 度分秒到弧度\r\n         * @param dms\r\n         * @return\r\n         */\n\n    }, {\n        key: \"DMS2Radian\",\n        value: function DMS2Radian(dms) {\n            var d = parseInt(dms);\n            var m = parseInt((dms - d) * 100);\n            var s = ((dms - d) * 100 - m) * 100;\n            return (parseFloat(d) + parseFloat(m / 60) + s / 3600) * Math.PI / 180;\n        }\n\n        /**\r\n         * 由WGS84到BJ54坐标转换\r\n         * @return\r\n         */\n\n    }, {\n        key: \"doConvert\",\n        value: function doConvert() {\n            this.setCoordType(this.CoordConst.CoordType_WGS84);\n            this.val1 = this.val1 * Math.PI / 180;\n            this.val2 = this.val2 * Math.PI / 180;\n            this.earth2Space();\n            this.space2Space(this.r);\n            this.setCoordType(this.coordType);\n            this.space2Earth();\n\n            var n = 0;\n            if (this.L0 > 0) {\n                n = this.L0;\n            } else {\n                var m = this.getMeridian();\n                if (m < 0) {\n                    return false;\n                }\n                n = this.DMS2Radian(m);\n            }\n\n            this.earth2Gauss(n);\n            return true;\n        }\n    }]);\n\n    return Param7;\n}();\n\n/* harmony default export */ var converttype_Param7 = (Param7);\n// CONCATENATED MODULE: ./egova/coordconvert/converttype/7BJ54.js\nvar _7BJ54_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _7BJ54_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\nvar _7BJ54_SERVEN_BJ54 = function (_Base) {\n    _inherits(SERVEN_BJ54, _Base);\n\n    function SERVEN_BJ54(params) {\n        _7BJ54_classCallCheck(this, SERVEN_BJ54);\n\n        var _this = _possibleConstructorReturn(this, (SERVEN_BJ54.__proto__ || Object.getPrototypeOf(SERVEN_BJ54)).call(this, params));\n\n        _this.param7 = new converttype_Param7(2, params);\n        return _this;\n    }\n\n    /**\r\n     * 四参数法将WGS84经纬度坐标转换为北京54平面坐标\r\n     * @param lon 将WGS84经度\r\n     * @param lat 将WGS84纬度\r\n     * @returns {*[]}\r\n     */\n\n\n    _7BJ54_createClass(SERVEN_BJ54, [{\n        key: 'convert',\n        value: function convert(lon, lat) {\n            return this.param7.convert(lon, lat);\n        }\n    }]);\n\n    return SERVEN_BJ54;\n}(converttype_Base);\n\nif (!coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.SERVEN_BJ54]) {\n    coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.SERVEN_BJ54] = _7BJ54_SERVEN_BJ54;\n}\n/* harmony default export */ var _7BJ54 = (_7BJ54_SERVEN_BJ54);\n// CONCATENATED MODULE: ./egova/coordconvert/converttype/7XA80.js\nvar _7XA80_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _7XA80_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _7XA80_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _7XA80_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\nvar _7XA80_SERVEN_XA80 = function (_Base) {\n    _7XA80_inherits(SERVEN_XA80, _Base);\n\n    function SERVEN_XA80(params) {\n        _7XA80_classCallCheck(this, SERVEN_XA80);\n\n        var _this = _7XA80_possibleConstructorReturn(this, (SERVEN_XA80.__proto__ || Object.getPrototypeOf(SERVEN_XA80)).call(this, params));\n\n        _this.param7 = new converttype_Param7(3, params);\n        return _this;\n    }\n\n    /**\r\n     * 四参数法将WGS84经纬度坐标转换为北京54平面坐标\r\n     * @param lon 将WGS84经度\r\n     * @param lat 将WGS84纬度\r\n     * @returns {*[]}\r\n     */\n\n\n    _7XA80_createClass(SERVEN_XA80, [{\n        key: 'convert',\n        value: function convert(lon, lat) {\n            return this.param7.convert(lon, lat);\n        }\n    }]);\n\n    return SERVEN_XA80;\n}(converttype_Base);\n\nif (!coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.SERVEN_XA80]) {\n    coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.SERVEN_XA80] = _7XA80_SERVEN_XA80;\n}\n/* harmony default export */ var _7XA80 = (_7XA80_SERVEN_XA80);\n// CONCATENATED MODULE: ./egova/coordconvert/converttype/7WGS84.js\nvar _7WGS84_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _7WGS84_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _7WGS84_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _7WGS84_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\nvar _7WGS84_SERVEN_WGS84 = function (_Base) {\n    _7WGS84_inherits(SERVEN_WGS84, _Base);\n\n    function SERVEN_WGS84(params) {\n        _7WGS84_classCallCheck(this, SERVEN_WGS84);\n\n        var _this = _7WGS84_possibleConstructorReturn(this, (SERVEN_WGS84.__proto__ || Object.getPrototypeOf(SERVEN_WGS84)).call(this, params));\n\n        _this.param7 = new converttype_Param7(1, params);\n        return _this;\n    }\n\n    /**\r\n     * 四参数法将WGS84经纬度坐标转换为北京54平面坐标\r\n     * @param lon 将WGS84经度\r\n     * @param lat 将WGS84纬度\r\n     * @returns {*[]}\r\n     */\n\n\n    _7WGS84_createClass(SERVEN_WGS84, [{\n        key: 'convert',\n        value: function convert(lon, lat) {\n            return this.param7.convert(lon, lat);\n        }\n    }]);\n\n    return SERVEN_WGS84;\n}(converttype_Base);\n\nif (!coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.SERVEN_WGS84]) {\n    coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.SERVEN_WGS84] = _7WGS84_SERVEN_WGS84;\n}\n/* harmony default export */ var _7WGS84 = (_7WGS84_SERVEN_WGS84);\n// CONCATENATED MODULE: ./egova/coordconvert/converttype/Param4.js\nvar Param4_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction Param4_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Param4 = function () {\n    function Param4(sysID, params) {\n        Param4_classCallCheck(this, Param4);\n\n        this.k0 = 1;\n        this.MA = [6378245, 6378140, 6378137];\n        this.MB = [6356863.0188, 6356755.2882, 6356752.3142];\n        this.L = 0; //经度°′″形式\n        this.B = 0; //纬度°′″形式\n        this.a = 0; //长轴\n        this.b = 0; //短轴\n        this.L0 = 0; //中央经度，弧度\n        this.coordSysID = 1; //坐标系：0:北京54采用;1:西安80; 2:WGS 84\n        this.DX = 0;\n        this.DY = 0;\n        this.T = 0;\n        this.K = 1;\n        this.isXYChange = false; //是否需要X与Y对调\n\n        if (sysID >= 0 && sysID <= 2) {\n            this.a = this.MA[sysID];\n            this.b = this.MB[sysID];\n        }\n        if (params) {\n            var pams = params.split(\"#\");\n            this.DX = parseFloat(pams[0].trim());\n            this.DY = parseFloat(pams[1].trim());\n            this.T = parseFloat(pams[2].trim());\n            this.K = parseFloat(pams[3].trim());\n\n            if (pams.length >= 5) {\n                if (pams[4].trim() == \"1\") this.isXYChange = true;\n            }\n            if (pams.length >= 6) {\n                this.L0 = parseFloat(pams[5].trim()) / 180 * Math.PI;\n            }\n        }\n    }\n\n    /**\r\n     * 四参数法坐标转换\r\n     * @param lon 经度\r\n     * @param lat 纬度\r\n     * @returns {*|Array}\r\n     */\n\n\n    Param4_createClass(Param4, [{\n        key: \"convert\",\n        value: function convert(lon, lat) {\n            var l1 = lon;\n            var b1 = lat;\n            var l2 = this.getRad(l1);\n            var b2 = this.getRad(b1);\n\n            if (this.L0 == 0) {\n                this.L0 = this.getMeridian(l2) / 180 * Math.PI;\n            }\n\n            this.L = l2;\n            this.B = b2;\n\n            var M = this.getM();\n            var A = this.getA();\n            var N = this.getN();\n            var T = this.getT();\n            var C = this.getC();\n            var FE = 500000;\n            var part1 = M;\n            var temp1 = Math.pow(A, 2) / 2 + (5 - T + 9 * C + 4 * Math.pow(C, 2)) * Math.pow(A, 4) / 24;\n            var part2 = N * Math.tan(this.B) * (Math.pow(A, 2) / 2 + (5 - T + 9 * C + 4 * Math.pow(C, 2)) * Math.pow(A, 4) / 24);\n            var part3 = (61 - 58 * T + Math.pow(T, 2) + 270 * C - 330 * T * C) * Math.pow(A, 6) / 720;\n\n            var x = part1 + part2 + part3;\n            part1 = FE;\n            part2 = A;\n            part3 = (1 - T + C) * Math.pow(A, 3) / 6;\n            var part4 = (5 - 18 * T - Math.pow(T, 2) + 14 * C - 58 * T * C) * Math.pow(A, 5) / 120;\n            var y = part1 + this.k0 * N * (part2 + part3 + part4);\n            var coord = this.trans(x, y);\n\n            return coord;\n        }\n\n        /**\r\n         * 获取3度带中央子午线\r\n         * @return\r\n         */\n\n    }, {\n        key: \"getMeridian\",\n        value: function getMeridian(val2) {\n            if (val2 < 0) {\n                return -1;\n            }\n            var L1 = val2 * 180 / Math.PI;\n            var L2 = parseInt(L1);\n            var left = L1 - L2;\n            var num = parseInt(L2 / 3);\n            left += L2 % 3;\n            if (left >= 1.5) num++;\n            return num * 3;\n        }\n    }, {\n        key: \"getRad\",\n        value: function getRad(d) {\n            return d / 180 * Math.PI;\n        }\n\n        /**\r\n         * 获得扁率 (a-b)/a\r\n         * @return double\r\n         */\n\n    }, {\n        key: \"getFlattening\",\n        value: function getFlattening() {\n            return (this.a - this.b) / this.a;\n        }\n\n        /**\r\n         * 获得第一偏心率 对（1-(b/a)*(b/a)）求根\r\n         * @return double\r\n         */\n\n    }, {\n        key: \"getEccentricity\",\n        value: function getEccentricity() {\n            return Math.sqrt(1 - Math.pow(this.b / this.a, 2));\n        }\n\n        /**\r\n         * 获得第二偏心率 对((a/b)*(a/b)-1)求根\r\n         * @param coordSysID int\r\n         * @return double\r\n         */\n\n    }, {\n        key: \"getSEccentricity\",\n        value: function getSEccentricity() {\n            var temp = this.a * 1.0 / this.b;\n            //System.out.println(\"getSEccentricity  a/b = \" + temp);\n            //System.out.println(\"e' = \" + Math.sqrt(temp * temp - 1));\n            return Math.sqrt(temp * temp - 1);\n        }\n\n        /**\r\n         * 获得卯酉圈曲率半径 a/对(1-(e*e) * (sinB*sinB))求根\r\n         * @param coordSysID int\r\n         * @param B double\r\n         * @return double\r\n         */\n\n    }, {\n        key: \"getN\",\n        value: function getN() {\n            var e = this.getEccentricity();\n            return this.a / Math.sqrt(1 - Math.pow(e, 2) * Math.pow(Math.sin(this.B), 2));\n        }\n\n        /**\r\n         * tgB * tgB\r\n         * @param coordSysID int\r\n         * @param B double\r\n         * @return double\r\n         */\n\n    }, {\n        key: \"getT\",\n        value: function getT() {\n            return Math.pow(Math.tan(this.B), 2);\n        }\n    }, {\n        key: \"getC\",\n        value: function getC() {\n            var se = this.getSEccentricity();\n            //System.out.println(\"\\tse*se = \" + se * se);\n            return Math.pow(se, 2) * Math.pow(Math.cos(this.B), 2);\n        }\n    }, {\n        key: \"getA\",\n        value: function getA() {\n            return (this.L - this.L0) * Math.cos(this.B);\n        }\n    }, {\n        key: \"getM\",\n        value: function getM() {\n            var e = this.getEccentricity();\n            var temp1 = 1 - Math.pow(e, 2) / 4 - 3 * Math.pow(e, 4) / 64 - 5 * Math.pow(e, 6) / 256;\n\n            var part1 = (1 - Math.pow(e, 2) / 4 - 3 * Math.pow(e, 4) / 64 - 5 * Math.pow(e, 6) / 256) * this.B;\n            var part2 = (3 * Math.pow(e, 2) / 8 + 3 * Math.pow(e, 4) / 32 + 45 * Math.pow(e, 6) / 1024) * Math.sin(2 * this.B);\n            var part3 = (15 * Math.pow(e, 4) / 256 + 45 * Math.pow(e, 6) / 1024) * Math.sin(4 * this.B);\n            var part4 = 35 * Math.pow(e, 6) / 3072 * Math.sin(6 * this.B);\n            return this.a * (part1 - part2 + part3 - part4);\n        }\n\n        /**\r\n         * 加偏移量和位置互换\r\n         * @param x\r\n         * @param y\r\n         * @returns {Array}\r\n         */\n\n    }, {\n        key: \"trans\",\n        value: function trans(x, y) {\n            var result = [];\n            if (this.isXYChange) {\n                //按现场实际情况，对调xy坐标\n                result[1] = this.DX + this.K * (x * Math.cos(this.T) - y * Math.sin(this.T));\n                result[0] = this.DY + this.K * (x * Math.sin(this.T) + y * Math.cos(this.T));\n            } else {\n                result[0] = this.DX + this.K * (x * Math.cos(this.T) - y * Math.sin(this.T));\n                result[1] = this.DY + this.K * (x * Math.sin(this.T) + y * Math.cos(this.T));\n            }\n            return result;\n        }\n    }]);\n\n    return Param4;\n}();\n\n/* harmony default export */ var converttype_Param4 = (Param4);\n// CONCATENATED MODULE: ./egova/coordconvert/converttype/BJ54.js\nvar BJ54_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction BJ54_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction BJ54_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction BJ54_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\nvar BJ54_BJ54 = function (_Base) {\n    BJ54_inherits(BJ54, _Base);\n\n    function BJ54(params) {\n        BJ54_classCallCheck(this, BJ54);\n\n        var _this = BJ54_possibleConstructorReturn(this, (BJ54.__proto__ || Object.getPrototypeOf(BJ54)).call(this, params));\n\n        _this.param4 = new converttype_Param4(0, params);\n        return _this;\n    }\n\n    /**\r\n     * 四参数法将WGS84经纬度坐标转换为北京54平面坐标\r\n     * @param lon 将WGS84经度\r\n     * @param lat 将WGS84纬度\r\n     * @returns {*[]}\r\n     */\n\n\n    BJ54_createClass(BJ54, [{\n        key: 'convert',\n        value: function convert(lon, lat) {\n            return this.param4.convert(lon, lat);\n        }\n    }]);\n\n    return BJ54;\n}(converttype_Base);\n\nif (!coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.FOUR_BJ54]) {\n    coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.FOUR_BJ54] = BJ54_BJ54;\n}\n/* harmony default export */ var converttype_BJ54 = (BJ54_BJ54);\n// CONCATENATED MODULE: ./egova/coordconvert/converttype/XA80.js\nvar XA80_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction XA80_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction XA80_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction XA80_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\nvar XA80_XA80 = function (_Base) {\n    XA80_inherits(XA80, _Base);\n\n    function XA80(params) {\n        XA80_classCallCheck(this, XA80);\n\n        var _this = XA80_possibleConstructorReturn(this, (XA80.__proto__ || Object.getPrototypeOf(XA80)).call(this, params));\n\n        _this.param4 = new converttype_Param4(1, params);\n        return _this;\n    }\n\n    /**\r\n     * 四参数法将WGS84经纬度坐标转换为北京54平面坐标\r\n     * @param lon 将WGS84经度\r\n     * @param lat 将WGS84纬度\r\n     * @returns {*[]}\r\n     */\n\n\n    XA80_createClass(XA80, [{\n        key: 'convert',\n        value: function convert(lon, lat) {\n            return this.param4.convert(lon, lat);\n        }\n    }]);\n\n    return XA80;\n}(converttype_Base);\n\nif (!coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.FOUR_XA80]) {\n    coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.FOUR_XA80] = XA80_XA80;\n}\n/* harmony default export */ var converttype_XA80 = (XA80_XA80);\n// CONCATENATED MODULE: ./egova/coordconvert/converttype/WGS84.js\nvar WGS84_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction WGS84_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction WGS84_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction WGS84_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\nvar WGS84_WGS84 = function (_Base) {\n    WGS84_inherits(WGS84, _Base);\n\n    function WGS84(params) {\n        WGS84_classCallCheck(this, WGS84);\n\n        var _this = WGS84_possibleConstructorReturn(this, (WGS84.__proto__ || Object.getPrototypeOf(WGS84)).call(this, params));\n\n        _this.param4 = new converttype_Param4(2, params);\n        return _this;\n    }\n\n    /**\r\n     * 四参数法将WGS84经纬度坐标转换为北京54平面坐标\r\n     * @param lon 将WGS84经度\r\n     * @param lat 将WGS84纬度\r\n     * @returns {*[]}\r\n     */\n\n\n    WGS84_createClass(WGS84, [{\n        key: 'convert',\n        value: function convert(lon, lat) {\n            return this.param4.convert(lon, lat);\n        }\n    }]);\n\n    return WGS84;\n}(converttype_Base);\n\nif (!coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.FOUR_WGS84]) {\n    coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.FOUR_WGS84] = WGS84_WGS84;\n}\n/* harmony default export */ var converttype_WGS84 = (WGS84_WGS84);\n// CONCATENATED MODULE: ./egova/coordconvert/converttype/YDCL.js\nvar YDCL_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction YDCL_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction YDCL_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction YDCL_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\nvar YDCL = function (_Base) {\n    YDCL_inherits(YDCL, _Base);\n\n    function YDCL(params) {\n        YDCL_classCallCheck(this, YDCL);\n\n        var _this = YDCL_possibleConstructorReturn(this, (YDCL.__proto__ || Object.getPrototypeOf(YDCL)).call(this, params));\n\n        _this.DX = 0;\n        _this.DY = 0;\n        _this.T = 0;\n        _this.K = 1;\n\n        _this.isXYChange = false; //是否需要X与Y对调\n        _this.L0 = 0; //中央经度，弧度\n        _this.datum = [6378137, 6356752.3142, 0.00669437999013];\n        if (_this.params) {\n            var pams = _this.params.split(\"#\");\n            _this.DX = parseFloat(pams[0].trim());\n            _this.DY = parseFloat(pams[1].trim());\n            _this.T = parseFloat(pams[2].trim()); /// 180 * Math.PI;\n            _this.K = parseFloat(pams[3].trim());\n\n            if (pams.length >= 5) {\n                if (pams[4].trim() == \"1\") _this.isXYChange = true;\n            }\n            if (pams.length >= 6) {\n                _this.L0 = parseFloat(pams[5].trim()); // / 180 * Math.PI;\n            }\n            console.log(\"DX=\" + _this.DX + \",DY=\" + _this.DY + \",T=\" + _this.T + \",K=\" + _this.K + \",isXYChange=\" + _this.isXYChange + \",L0=\" + _this.L0);\n        } else {\n            console.log(\"坐标转换参数为空，将使用默认参数.\");\n        }\n        return _this;\n    }\n\n    /**\r\n     * 将经纬坐标转换为城市坐标.\r\n     * @param l 地理经度坐标, 度度\r\n     * @param b 地理纬度坐标, 度度\r\n     * @return 城市坐标[x, y]\r\n     */\n\n\n    YDCL_createClass(YDCL, [{\n        key: 'convert',\n        value: function convert(l, b) {\n            var gaparams = this.GaussProjCal(b, l, 0);\n            var result = this.Para4Convert(gaparams);\n            if (this.isXYChange) {\n                return [result[1], result[0]];\n            }\n            return [result[0], result[1]];\n        }\n\n        /**\r\n         * 高斯投影由经纬度(Unit:DD)计算大地平面坐标(含带号，Unit:Metres) \r\n         * @param b\r\n         * @param l\r\n         * @param h\r\n         * @return\r\n         */\n\n    }, {\n        key: 'GaussProjCal',\n        value: function GaussProjCal(b, l, h) {\n            var ProjNo, ZoneWide; ////带宽 \n            var longitude0, X0, xval, yval;\n            var a, e2, ee, NN, T, C, A, M;\n            ZoneWide = 3; //3度带宽 \n            a = parseFloat(this.datum[0]);\n            ProjNo = parseInt((l - 1.5) / ZoneWide + 1);\n            longitude0 = this.L0;\n            if (Math.abs(this.L0 - 0) < 0.000001) {\n                longitude0 = ProjNo * ZoneWide; //中央经线\n            }\n            longitude0 = longitude0 * Math.PI / 180;\n            l = l * Math.PI / 180; //经度转换为弧度\n            b = b * Math.PI / 180; //纬度转换为弧度\n            e2 = this.datum[2];\n            ee = e2 * (1.0 - e2);\n            NN = a / Math.sqrt(1.0 - e2 * Math.sin(b) * Math.sin(b));\n            T = Math.tan(b) * Math.tan(b);\n            C = ee * Math.cos(b) * Math.cos(b);\n            A = (l - longitude0) * Math.cos(b);\n\n            M = a * ((1 - e2 / 4 - 3 * e2 * e2 / 64 - 5 * e2 * e2 * e2 / 256) * b - (3 * e2 / 8 + 3 * e2 * e2 / 32 + 45 * e2 * e2 * e2 / 1024) * Math.sin(2 * b) + (15 * e2 * e2 / 256 + 45 * e2 * e2 * e2 / 1024) * Math.sin(4 * b) - 35 * e2 * e2 * e2 / 3072 * Math.sin(6 * b));\n            xval = NN * (A + (1 - T + C) * A * A * A / 6 + (5 - 18 * T + T * T + 72 * C - 58 * ee) * A * A * A * A * A / 120);\n            yval = M + NN * Math.tan(b) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24 + (61 - 58 * T + T * T + 600 * C - 330 * ee) * A * A * A * A * A * A / 720);\n            //X0 = 1000000L * ProjNo + 500000L;\n            X0 = parseFloat(500000);\n            xval = xval + X0;\n            return [xval, yval, h];\n        }\n\n        /**\r\n         * 利用4参数求新坐标系的坐标\r\n         * @param aPtSource\r\n         * @return\r\n         */\n\n    }, {\n        key: 'Para4Convert',\n        value: function Para4Convert(aPtSource) {\n            var k = parseFloat(this.K);\n            var a1 = parseFloat(k * Math.cos(this.T));\n            var a2 = parseFloat(k * Math.sin(this.T));\n\n            var ToCoordinate = new Array(3);\n            ToCoordinate[0] = this.DX + a1 * aPtSource[0] + a2 * aPtSource[1];\n            ToCoordinate[1] = this.DY + a1 * aPtSource[1] - a2 * aPtSource[0];\n            ToCoordinate[2] = aPtSource[2];\n\n            return ToCoordinate;\n        }\n    }]);\n\n    return YDCL;\n}(converttype_Base);\n\nif (!coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.YDCL]) {\n    coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.YDCL] = YDCL;\n}\n/* harmony default export */ var converttype_YDCL = (YDCL);\n// CONCATENATED MODULE: ./egova/coordconvert/converttype/GPS.js\nvar GPS_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction GPS_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction GPS_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction GPS_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\nvar GPS = function (_Base) {\n    GPS_inherits(GPS, _Base);\n\n    function GPS(params) {\n        GPS_classCallCheck(this, GPS);\n\n        var _this = GPS_possibleConstructorReturn(this, (GPS.__proto__ || Object.getPrototypeOf(GPS)).call(this, params));\n\n        _this.DX = 0;\n        _this.DY = 0;\n        _this.isXYChange = false;\n        if (_this.params) {\n            var pams = _this.params.split(\"#\");\n            _this.DX = parseFloat(pams[0].trim());\n            _this.DY = parseFloat(pams[1].trim());\n            if (pams.length >= 3) {\n                if (pams[2].trim() == \"1\") _this.isXYChange = true;\n            }\n        }\n        return _this;\n    }\n\n    /**\r\n     * 将经纬度转换为GPS坐标\r\n     * @param lon\r\n     * @param lat\r\n     * @returns {*[]}\r\n     */\n\n\n    GPS_createClass(GPS, [{\n        key: 'convert',\n        value: function convert(lon, lat) {\n            var lon_lat = [];\n            lon_lat[0] = lon + this.DX;\n            lon_lat[1] = lat + this.DY;\n            if (this.isXYChange) return [lon_lat[1], lon_lat[0]];else return lon_lat;\n        }\n    }]);\n\n    return GPS;\n}(converttype_Base);\n\nif (!coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.GPS]) {\n    coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.GPS] = GPS;\n}\nif (!coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.NULL]) {\n    coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.NULL] = GPS;\n}\n/* harmony default export */ var converttype_GPS = (GPS);\n// CONCATENATED MODULE: ./egova/coordconvert/converttype/MKT.js\nvar MKT_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction MKT_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction MKT_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction MKT_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\nvar MKT = function (_Base) {\n    MKT_inherits(MKT, _Base);\n\n    function MKT(params) {\n        MKT_classCallCheck(this, MKT);\n\n        return MKT_possibleConstructorReturn(this, (MKT.__proto__ || Object.getPrototypeOf(MKT)).call(this, params));\n    }\n\n    /**\r\n     * 将经纬度转换为墨卡托投影平面坐标\r\n     * @param lon\r\n     * @param lat\r\n     * @returns {*[]}\r\n     */\n\n\n    MKT_createClass(MKT, [{\n        key: 'convert',\n        value: function convert(lon, lat) {\n            var x = lon * 20037508.34 / 180;\n            var y = Math.log(Math.tan((90 + lat) * Math.PI / 360)) / (Math.PI / 180);\n            y = y * 20037508.34 / 180;\n            return [x, y];\n        }\n    }]);\n\n    return MKT;\n}(converttype_Base);\n\nif (!coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.MKT]) {\n    coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.MKT] = MKT;\n}\n/* harmony default export */ var converttype_MKT = (MKT);\n// CONCATENATED MODULE: ./egova/coordconvert/converttype/GD.js\nvar GD_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction GD_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction GD_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction GD_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\nvar GD_GD = function (_Base) {\n    GD_inherits(GD, _Base);\n\n    function GD(params) {\n        GD_classCallCheck(this, GD);\n\n        var _this = GD_possibleConstructorReturn(this, (GD.__proto__ || Object.getPrototypeOf(GD)).call(this, params));\n\n        _this.x_PI = 3.14159265358979324 * 3000.0 / 180.0;\n        _this.PI = 3.1415926535897932384626;\n        _this.a = 6378245.0;\n        _this.ee = 0.00669342162296594323;\n        _this.DX = 0;\n        _this.DY = 0;\n        _this.isXYChange = false;\n        _this.isMercator = true;\n        _this.mktObj = new converttype_MKT(\"\");\n        if (_this.params) {\n            var pams = _this.params.split(\"#\");\n            _this.DX = parseFloat(pams[0].trim());\n            _this.DY = parseFloat(pams[1].trim());\n            if (pams.length >= 3) {\n                if (pams[2].trim() == \"1\") _this.isXYChange = true;\n            }\n            if (pams.length >= 4) {\n                if (pams[3].trim() == \"1\") {\n                    _this.isMercator = true;\n                } else if (pams[3].trim() == \"0\") {\n                    _this.isMercator = false;\n                }\n            }\n        }\n        return _this;\n    }\n\n    /**\r\n     * 将WGS84经纬度坐标转换为百度经纬度或百度平面\r\n     * @param lon 将WGS84经度\r\n     * @param lat 将WGS84纬度\r\n     * @returns {*[]}\r\n     */\n\n\n    GD_createClass(GD, [{\n        key: 'convert',\n        value: function convert(lon, lat) {\n            var latLng = this.wgs84ll2gcj02ll(lon, lat);\n            var xy = latLng;\n            if (this.isMercator) {\n                xy = this.mktObj.convert(latLng[0], latLng[1]);\n            }\n\n            xy[0] = xy[0] + this.DX;\n            xy[1] = xy[1] + this.DY;\n\n            if (!this.isXYChange) {\n                return xy;\n            } else {\n                return [xy[1], xy[0]];\n            }\n        }\n\n        /**\r\n         * WGS84转GCj02经纬度\r\n         * @param longitude\r\n         * @param latitude\r\n         * @returns {*[]}\r\n         */\n\n    }, {\n        key: 'wgs84ll2gcj02ll',\n        value: function wgs84ll2gcj02ll(longitude, latitude) {\n            var lat = +latitude;\n            var lng = +longitude;\n            if (this.out_of_china(lng, lat)) {\n                return [lng, lat];\n            } else {\n                var dlat = this.transformlat(lng - 105.0, lat - 35.0);\n                var dlng = this.transformlng(lng - 105.0, lat - 35.0);\n                var radlat = lat / 180.0 * this.PI;\n                var magic = Math.sin(radlat);\n                magic = 1 - this.ee * magic * magic;\n                var sqrtmagic = Math.sqrt(magic);\n                dlat = dlat * 180.0 / (this.a * (1 - this.ee) / (magic * sqrtmagic) * this.PI);\n                dlng = dlng * 180.0 / (this.a / sqrtmagic * Math.cos(radlat) * this.PI);\n                var mglat = lat + dlat;\n                var mglng = lng + dlng;\n                return [mglng, mglat];\n            }\n        }\n    }, {\n        key: 'wgs84ll2bdll',\n        value: function wgs84ll2bdll(longitude, latitude) {\n            if (this.out_of_china(longitude, latitude)) {\n                return [longitude, latitude];\n            } else {\n                var gcj = this.wgs84ll2gcj02ll(longitude, latitude);\n                var bdll = this.gcj02ll2bdll(gcj[0], gcj[1]);\n                return bdll;\n            }\n        }\n\n        /**\r\n         * 火星坐标系 (GCJ-02)经纬度 转百度坐标系 (BD-09) 经纬度\r\n         * 即谷歌、高德 转 百度\r\n         * @param longitude\r\n         * @param latitude\r\n         * @returns {*[]}\r\n         */\n\n    }, {\n        key: 'gcj02ll2bdll',\n        value: function gcj02ll2bdll(longitude, latitude) {\n            var lat = +latitude;\n            var lng = +longitude;\n            var z = Math.sqrt(lng * lng + lat * lat) + 0.00002 * Math.sin(lat * this.x_PI);\n            var theta = Math.atan2(lat, lng) + 0.000003 * Math.cos(lng * this.x_PI);\n            var bd_lng = z * Math.cos(theta) + 0.0065;\n            var bd_lat = z * Math.sin(theta) + 0.006;\n            return [bd_lng, bd_lat];\n        }\n\n        /**\r\n         * 火星坐标系 (GCJ-02)经纬度 转wgs84经纬度\r\n         * 即谷歌、高德 转 wgs84\r\n         * @param longitude\r\n         * @param latitude\r\n         * @returns {*[]}\r\n         */\n\n    }, {\n        key: 'gcj02ll2wgs84ll',\n        value: function gcj02ll2wgs84ll(longitude, latitude) {\n            if (this.out_of_china(longitude, latitude)) {\n                return [longitude, latitude];\n            }\n            var d = this.delta(latitude, longitude);\n            return [longitude - d[1], latitude - d[0]];\n        }\n\n        /**\r\n         * 判断是否在国内，不在国内则不做偏移\r\n         * @param longitude\r\n         * @param latitude\r\n         * @returns {boolean}\r\n         */\n\n    }, {\n        key: 'out_of_china',\n        value: function out_of_china(longitude, latitude) {\n            // 纬度3.86~53.55,经度73.66~135.05\n            var result = !(longitude > 73.66 && longitude < 135.05 && latitude > 3.86 && latitude < 53.55);\n            return result;\n        }\n    }, {\n        key: 'transformlat',\n        value: function transformlat(longitude, latitude) {\n            var lat = +latitude;\n            var lng = +longitude;\n            var ret = -100.0 + 2.0 * lng + 3.0 * lat + 0.2 * lat * lat + 0.1 * lng * lat + 0.2 * Math.sqrt(Math.abs(lng));\n            ret += (20.0 * Math.sin(6.0 * lng * this.PI) + 20.0 * Math.sin(2.0 * lng * this.PI)) * 2.0 / 3.0;\n            ret += (20.0 * Math.sin(lat * this.PI) + 40.0 * Math.sin(lat / 3.0 * this.PI)) * 2.0 / 3.0;\n            ret += (160.0 * Math.sin(lat / 12.0 * this.PI) + 320 * Math.sin(lat * this.PI / 30.0)) * 2.0 / 3.0;\n            return ret;\n        }\n    }, {\n        key: 'transformlng',\n        value: function transformlng(longitude, latitude) {\n            var lat = +latitude;\n            var lng = +longitude;\n            var ret = 300.0 + lng + 2.0 * lat + 0.1 * lng * lng + 0.1 * lng * lat + 0.1 * Math.sqrt(Math.abs(lng));\n            ret += (20.0 * Math.sin(6.0 * lng * this.PI) + 20.0 * Math.sin(2.0 * lng * this.PI)) * 2.0 / 3.0;\n            ret += (20.0 * Math.sin(lng * this.PI) + 40.0 * Math.sin(lng / 3.0 * this.PI)) * 2.0 / 3.0;\n            ret += (150.0 * Math.sin(lng / 12.0 * this.PI) + 300.0 * Math.sin(lng / 30.0 * this.PI)) * 2.0 / 3.0;\n            return ret;\n        }\n    }, {\n        key: 'delta',\n        value: function delta(lat, lon) {\n            var a = 6378245.0;\n            var ee = 0.00669342162296594323;\n            var dLat = this.transformlat(lon - 105.0, lat - 35.0);\n            var dLon = this.transformlng(lon - 105.0, lat - 35.0);\n            var radLat = lat / 180.0 * this.PI;\n            var magic = Math.sin(radLat);\n            magic = 1 - ee * magic * magic;\n            var sqrtMagic = Math.sqrt(magic);\n            dLat = dLat * 180.0 / (a * (1 - ee) / (magic * sqrtMagic) * this.PI);\n            dLon = dLon * 180.0 / (a / sqrtMagic * Math.cos(radLat) * this.PI);\n            return [dLat, dLon];\n        }\n\n        /**\r\n         * 百度经纬度到gcj02经纬度\r\n         * @param longitude\r\n         * @param latitude\r\n         * @returns {*[]}\r\n         */\n\n    }, {\n        key: 'bdll2gcjll',\n        value: function bdll2gcjll(lat, lon) {\n            var x = lon - 0.0065,\n                y = lat - 0.006;\n            var z = Math.sqrt(x * x + y * y) - 0.00002 * Math.sin(y * this.x_PI);\n            var theta = Math.atan2(y, x) - 0.000003 * Math.cos(x * this.x_PI);\n            var gg_lon = z * Math.cos(theta);\n            var gg_lat = z * Math.sin(theta);\n            return [gg_lon, gg_lat];\n        }\n\n        /**\r\n         * 百度经纬度到wgs84经纬度\r\n         * @param longitude\r\n         * @param latitude\r\n         * @returns {*[]}\r\n         */\n\n    }, {\n        key: 'bdll2wgs84ll',\n        value: function bdll2wgs84ll(lon, lat) {\n            var gcj02ll = this.bdll2gcjll(lat, lon);\n            var wgs84ll = this.gcj02ll2wgs84ll(gcj02ll[0], gcj02ll[1]);\n            return wgs84ll;\n        }\n\n        /**\r\n         * 经纬度到墨卡托平面\r\n         * @param longitude\r\n         * @param latitude\r\n         * @returns {*[]}\r\n         */\n\n    }, {\n        key: 'latLon2Mercator',\n        value: function latLon2Mercator(lat, lon) {\n            var x = lon * 20037508.34 / 180;\n            var y = Math.log(Math.tan((90 + lat) * this.PI / 360)) / (this.PI / 180);\n            y = y * 20037508.34 / 180;\n\n            return [x, y];\n        }\n\n        /**\r\n         * 墨卡托平面到经纬度\r\n         * @param x\r\n         * @param y\r\n         * @returns {*[]}\r\n         */\n\n    }, {\n        key: 'mercator2LatLon',\n        value: function mercator2LatLon(x, y) {\n            var lon = x / 20037508.34 * 180;\n            var lat = y / 20037508.34 * 180;\n            lat = 180 / this.PI * (2 * Math.atan(Math.exp(lat * Math.PI / 180)) - Math.PI / 2);\n\n            return [lon, lat];\n        }\n    }]);\n\n    return GD;\n}(converttype_Base);\n\nif (!coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.GD]) {\n    coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.GD] = GD_GD;\n}\n/* harmony default export */ var converttype_GD = (GD_GD);\n// CONCATENATED MODULE: ./egova/coordconvert/converttype/BD.js\nvar BD_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction BD_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction BD_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction BD_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\nvar BD_BD = function (_Base) {\n    BD_inherits(BD, _Base);\n\n    function BD(params) {\n        BD_classCallCheck(this, BD);\n\n        var _this = BD_possibleConstructorReturn(this, (BD.__proto__ || Object.getPrototypeOf(BD)).call(this, params));\n\n        _this.MC2LL = [[1.410526172116255e-8, 898305509648872e-20, -1.9939833816331, 200.9824383106796, -187.2403703815547, 91.6087516669843, -23.38765649603339, 2.57121317296198, -.03801003308653, 17337981.2], [-7.435856389565537e-9, 8983055097726239e-21, -.78625201886289, 96.32687599759846, -1.85204757529826, -59.36935905485877, 47.40033549296737, -16.50741931063887, 2.28786674699375, 10260144.86], [-3.030883460898826e-8, 898305509983578e-20, .30071316287616, 59.74293618442277, 7.357984074871, -25.38371002664745, 13.45380521110908, -3.29883767235584, .32710905363475, 6856817.37], [-1.981981304930552e-8, 8983055099779535e-21, .03278182852591, 40.31678527705744, .65659298677277, -4.44255534477492, .85341911805263, .12923347998204, -.04625736007561, 4482777.06], [3.09191371068437e-9, 8983055096812155e-21, 6995724062e-14, 23.10934304144901, -.00023663490511, -.6321817810242, -.00663494467273, .03430082397953, -.00466043876332, 2555164.4], [2.890871144776878e-9, 8983055095805407e-21, -3.068298e-8, 7.47137025468032, -353937994e-14, -.02145144861037, -1234426596e-14, .00010322952773, -323890364e-14, 826088.5]];\n        _this.LL2MC = [[-.0015702102444, 111320.7020616939, 1704480524535203.0, -10338987376042340.0, 26112667856603880.0, -35149669176653700.0, 26595700718403920.0, -10725012454188240.0, 1800819912950474.0, 82.5], [.0008277824516172526, 111320.7020463578, 647795574.6671607, -4082003173.641316, 10774905663.51142, -15171875531.51559, 12053065338.62167, -5124939663.577472, 913311935.9512032, 67.5], [.00337398766765, 111320.7020202162, 4481351.045890365, -23393751.19931662, 79682215.47186455, -115964993.2797253, 97236711.15602145, -43661946.33752821, 8477230.501135234, 52.5], [.00220636496208, 111320.7020209128, 51751.86112841131, 3796837.749470245, 992013.7397791013, -1221952.21711287, 1340652.697009075, -620943.6990984312, 144416.9293806241, 37.5], [-.0003441963504368392, 111320.7020576856, 278.2353980772752, 2485758.690035394, 6070.750963243378, 54821.18345352118, 9540.606633304236, -2710.55326746645, 1405.483844121726, 22.5], [-.0003218135878613132, 111320.7020701615, .00369383431289, 823725.6402795718, .46104986909093, 2351.343141331292, 1.58060784298199, 8.77738589078284, .37238884252424, 7.45]];\n        _this.MCBAND = [12890594.86, 8362377.87, 5591021, 3481989.83, 1678043.12, 0];\n        _this.LLBAND = [75, 60, 45, 30, 15, 0];\n        _this.type = 1; //1百度米制坐标，2百度经纬度坐标 默认为1\n        _this.gdObj = new converttype_GD(\"\");\n        if (_this.params) {\n            if (_this.params == \"2\") {\n                _this.type = 2;\n            } else {\n                _this.type = 1;\n            }\n        }\n        return _this;\n    }\n\n    /**\r\n     * 将WGS84经纬度坐标转换为百度经纬度或百度平面\r\n     * @param lon 将WGS84经度\r\n     * @param lat 将WGS84纬度\r\n     * @returns {*[]}\r\n     */\n\n\n    BD_createClass(BD, [{\n        key: 'convert',\n        value: function convert(lon, lat) {\n            var bdll = this.gdObj.wgs84ll2bdll(lon, lat);\n\n            if (this.type == 2) {\n                console.info(\"百度经纬度：\" + lon + \",\" + lat + \",\" + bdll[0] + \",\" + bdll[1]);\n                return bdll;\n            } else {\n                var bdmc = this.bdll2bdmc(bdll[0], bdll[1]);\n                console.info(\"百度米：\" + lon + \",\" + lat + \",\" + bdmc[0] + \",\" + bdmc[1]);\n                return bdmc;\n            }\n        }\n\n        /**\r\n         * 百度经纬度转百度平面(米制坐标)\r\n         * @param bd_lon 百度经度\r\n         * @param bd_lat 百度纬度\r\n         * @returns {*}\r\n         */\n\n    }, {\n        key: 'bdmc2bdll',\n        value: function bdmc2bdll(x, y) {\n            var e = [Math.abs(x), Math.abs(y)];\n            var i = null;\n            for (var n = 0; n < this.MCBAND.length; n++) {\n                if (e[1] >= this.MCBAND[n]) {\n                    i = this.MC2LL[n];\n                    break;\n                }\n            }return this.convertor(e, i);\n        }\n        /**\r\n         * 百度经纬度转百度平面(米制坐标)\r\n         * @param bd_lon 百度经度\r\n         * @param bd_lat 百度纬度\r\n         * @returns {*}\r\n         */\n\n    }, {\n        key: 'bdll2bdmc',\n        value: function bdll2bdmc(bd_lon, bd_lat) {\n            var e;\n            var i = null;\n            var x = this.getLoop(bd_lon, -180, 180);\n            var y = this.getRange(bd_lat, -74, 74);\n            e = [x, y];\n            for (var n = 0; n < this.LLBAND.length; n++) {\n                if (e[1] >= this.LLBAND[n]) {\n                    i = this.LL2MC[n];\n                    break;\n                }\n            }\n            if (i == null) {\n                for (var n = this.LLBAND.length - 1; n >= 0; n--) {\n                    if (e[1] <= -this.LLBAND[n]) {\n                        i = this.LL2MC[n];\n                        break;\n                    }\n                }\n            }\n            return this.convertor([x, y], i);\n        }\n    }, {\n        key: 'convertor',\n        value: function convertor(t, e) {\n            if (t != null && e != null) {\n                var i = e[0] + e[1] * Math.abs(t[0]),\n                    n = Math.abs(t[1]) / e[9],\n                    a = e[2] + e[3] * n + e[4] * n * n + e[5] * n * n * n + e[6] * n * n * n * n + e[7] * n * n * n * n * n + e[8] * n * n * n * n * n * n;\n                i *= t[0] < 0 ? -1 : 1;\n                a *= t[1] < 0 ? -1 : 1;\n                //保留小数点后6位\n                i = parseFloat(i.toFixed(6));\n                a = parseFloat(a.toFixed(6));\n                return [i, a];\n            }\n            return null;\n        }\n    }, {\n        key: 'getLoop',\n        value: function getLoop(t, e, i) {\n            for (; t > i;) {\n                t -= i - e;\n            }\n            for (; e > t;) {\n                t += i - e;\n            }\n            return t;\n        }\n    }, {\n        key: 'getRange',\n        value: function getRange(t, e, i) {\n            t = Math.max(t, e);\n            t = Math.min(t, i);\n            return t;\n        }\n    }]);\n\n    return BD;\n}(converttype_Base);\n\nif (!coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.BD]) {\n    coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.BD] = BD_BD;\n}\n/* harmony default export */ var converttype_BD = (BD_BD);\n// CONCATENATED MODULE: ./egova/coordconvert/converttype/BJCG.js\nvar BJCG_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction BJCG_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction BJCG_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction BJCG_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\nvar BJCG = function (_Base) {\n    BJCG_inherits(BJCG, _Base);\n\n    function BJCG(params) {\n        BJCG_classCallCheck(this, BJCG);\n\n        var _this = BJCG_possibleConstructorReturn(this, (BJCG.__proto__ || Object.getPrototypeOf(BJCG)).call(this, params));\n\n        _this.m_bIsUseRadom = true;\n        _this.m_dRadomValue = 40;\n        _this.DX = 0;\n        _this.DY = 0;\n        _this.T = 0;\n        _this.K = 1;\n        if (_this.params) {\n            var pams = _this.params.split(\"#\");\n            _this.DX = parseFloat(pams[0].trim());\n            _this.DY = parseFloat(pams[1].trim());\n            _this.T = parseFloat(pams[2].trim());\n            _this.K = parseFloat(pams[3].trim());\n        }\n        return _this;\n    }\n\n    /**\r\n     * 将经纬度转换为北京海淀、东城平面坐标\r\n     * @param lon\r\n     * @param lat\r\n     * @returns {*[]}\r\n     */\n\n\n    BJCG_createClass(BJCG, [{\n        key: 'convert',\n        value: function convert(lon, lat) {\n            var x = this.GetX(lon, lat);\n            var y = this.GetY(lon, lat);\n            var resultX = this.DX + this.K * (x * Math.cos(this.T) - y * Math.sin(this.T));\n            var resultY = this.DY + this.K * (x * Math.sin(this.T) + y * Math.cos(this.T));\n            return [resultX, resultY];\n        }\n    }, {\n        key: 'GetX',\n        value: function GetX(dx, dy) {\n            var Ax = 6103729.01171875;\n            var Bx = -158449219.125;\n            var Cx = -709804016;\n            var Dx = 18920915837.022213;\n            var fx = Ax * dx * dy + Bx * dx + Cx * dy + Dx;\n            if (this.m_bIsUseRadom) return fx / 1000 + this.GetRandom(this.m_dRadomValue);else return fx / 1000;\n        }\n    }, {\n        key: 'GetY',\n        value: function GetY(dx, dy) {\n            var Ay = 7662548.3125;\n            var By = -305916495;\n            var Cy = -780249200;\n            var Dy = 31456748837.828285;\n            var fy = Ay * dx * dy + By * dx + Cy * dy + Dy;\n            if (this.m_bIsUseRadom) return fy / 1000 + this.GetRandom(this.m_dRadomValue);else return fy / 1000;\n        }\n    }, {\n        key: 'GetRandom',\n        value: function GetRandom(dValue) {\n            return dValue * (Math.random() - 0.5);\n        }\n    }]);\n\n    return BJCG;\n}(converttype_Base);\n\nif (!coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.BJCG]) {\n    coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.BJCG] = BJCG;\n}\n/* harmony default export */ var converttype_BJCG = (BJCG);\n// CONCATENATED MODULE: ./egova/coordconvert/converttype/HZCG.js\nvar HZCG_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction HZCG_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction HZCG_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction HZCG_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\nvar HZCG = function (_Base) {\n    HZCG_inherits(HZCG, _Base);\n\n    function HZCG(params) {\n        HZCG_classCallCheck(this, HZCG);\n\n        return HZCG_possibleConstructorReturn(this, (HZCG.__proto__ || Object.getPrototypeOf(HZCG)).call(this, params));\n    }\n\n    /**\r\n     * 将经纬度转换为杭州城管坐标\r\n     * @param lon\r\n     * @param lat\r\n     * @returns {*[]}\r\n     */\n\n\n    HZCG_createClass(HZCG, [{\n        key: 'convert',\n        value: function convert(lon, lat) {\n            var x = 6378137.0;\n            var num2 = 0.0033528131778969143;\n            var l = this.angle_arc2(lon);\n            var b = this.angle_arc2(lat);\n            var a = 120.0;\n            var num5 = x * (1.0 - num2);\n            var num3 = Math.sqrt(Math.pow(x, 2.0) - Math.pow(num5, 2.0)) / x;\n            var num4 = Math.sqrt(Math.pow(x, 2.0) - Math.pow(num5, 2.0)) / num5;\n            var num17 = l - this.angle_arc(a);\n            var num15 = Math.tan(b);\n            var num16 = num4 * Math.cos(b);\n            var num14 = Math.sqrt(1.0 - Math.pow(num3, 2.0) * Math.pow(Math.sin(b), 2.0));\n            var num13 = x / num14;\n            var num19 = 1.0 + 0.75 * Math.pow(num3, 2.0) + 0.703125 * Math.pow(num3, 4.0) + 0.68359375 * Math.pow(num3, 6.0) + 0.67291259765625 * Math.pow(num3, 8.0);\n            var num20 = -0.5 * (0.75 * Math.pow(num3, 2.0) + 0.9375 * Math.pow(num3, 4.0) + 1.025390625 * Math.pow(num3, 6.0) + 1.07666015625 * Math.pow(num3, 8.0));\n            var num21 = 0.25 * (0.234375 * Math.pow(num3, 4.0) + 0.41015625 * Math.pow(num3, 6.0) + 0.538330078125 * Math.pow(num3, 8.0));\n            var num22 = -0.16666666666666666 * (0.068359375 * Math.pow(num3, 6.0) + 0.15380859375 * Math.pow(num3, 8.0));\n            var num23 = 0.125 * (0.01922607421875 * Math.pow(num3, 8.0));\n            var num18 = x * (1.0 - Math.pow(num3, 2.0)) * (num19 * b + num20 * Math.sin(2.0 * b) + num21 * Math.sin(4.0 * b) + num22 * Math.sin(6.0 * b) + num23 * Math.sin(8.0 * b));\n            var num8 = num18 + 0.5 * num13 * num15 * Math.pow(Math.cos(b), 2.0) * Math.pow(num17, 2.0) + 0.041666666666666664 * num13 * num15 * (5.0 - Math.pow(num15, 2.0) + 9.0 * Math.pow(num16, 2.0) + 4.0 * Math.pow(num16, 4.0)) * Math.pow(Math.cos(b), 4.0) * Math.pow(num17, 4.0) + 0.0013888888888888889 * num13 * num15 * (61.0 - 58.0 * Math.pow(num15, 2.0) + Math.pow(num15, 4.0) + 270.0 * Math.pow(num16, 2.0) - 330.0 * Math.pow(num16, 2.0) * Math.pow(num15, 2.0)) * Math.pow(Math.cos(b), 6.0) * Math.pow(num17, 6.0);\n            var num9 = num13 * Math.cos(b) * num17 + 0.16666666666666666 * num13 * (1.0 - Math.pow(num15, 2.0) + Math.pow(num16, 2.0)) * Math.pow(Math.cos(b), 3.0) * Math.pow(num17, 3.0) + 0.0083333333333333332 * num13 * (5.0 - 18.0 * Math.pow(num15, 2.0) + Math.pow(num15, 4.0) + 14.0 * Math.pow(num16, 2.0) - 58.0 * Math.pow(num16, 2.0) * Math.pow(num15, 2.0)) * Math.pow(Math.cos(b), 5.0) * Math.pow(num17, 5.0);\n            num9 += 500000.0;\n            var num24 = 83.840107;\n            var num25 = -83.745194;\n            var d = 3.7684E-06;\n            var num27 = 0.999991181043;\n            var num6 = num24 + num27 * Math.cos(d) * num8 - num27 * Math.sin(d) * num9;\n            var num7 = num25 + num27 * Math.sin(d) * num8 + num27 * Math.cos(d) * num9;\n            num24 = -3266736.9496;\n            num25 = -439821.9753;\n            d = this.angle_arc(0.0435048);\n            num27 = 1.0;\n            var num10 = num24 + num27 * Math.cos(d) * num6 - num27 * Math.sin(d) * num7;\n            var num11 = num25 + num27 * Math.sin(d) * num6 + num27 * Math.cos(d) * num7;\n\n            return [num11, num10];\n        }\n    }, {\n        key: 'angle_arc',\n        value: function angle_arc(a) {\n            return this.angle_descAngle(a) / 180.0 * 3.1415926535897931;\n        }\n    }, {\n        key: 'angle_arc2',\n        value: function angle_arc2(a) {\n            return a / 180.0 * 3.1415926535897931;\n        }\n    }, {\n        key: 'angle_descAngle',\n        value: function angle_descAngle(a) {\n            var num;\n            var num2;\n            var num3;\n            var str = \"\" + a;\n            var index = str.indexOf(\".\");\n            if (index < 0) {\n                num = parseInt(str, 0);\n                num2 = 0;\n                num3 = 0.0;\n            } else {\n                num = parseInt(str.substring(0, index), 0);\n                var str2 = str.substring(index);\n                if (str2.length == 0) {\n                    num2 = 0;\n                    num3 = 0.0;\n                } else {\n                    str2 = str2.substring(1);\n                    if (str2.length == 0) {\n                        num2 = 0;\n                        num3 = 0.0;\n                    } else if (str2.length == 1) {\n                        num2 = parseInt(str2, 0) * 10;\n                        num3 = 0.0;\n                    } else if (str2.length == 2) {\n                        num2 = parseInt(str2, 0);\n                        num3 = 0.0;\n                    } else {\n                        num2 = parseInt(str2.substring(0, 2), 0);\n                        str2 = str2.substring(2);\n                        if (str2.length == 0) {\n                            num3 = 0.0;\n                        } else if (str2.length == 1) {\n                            num3 = parseFloat(str2) * 10.0;\n                        } else if (str2.length == 2) {\n                            num3 = parseFloat(str2);\n                        } else {\n                            num3 = parseFloat(str2.substring(0, 2) + \".\" + str2.substring(2));\n                        }\n                    }\n                }\n            }\n            return num / 1.0 + num2 / 60.0 + num3 / 60.0 / 60.0;\n        }\n    }]);\n\n    return HZCG;\n}(converttype_Base);\n\nif (!coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.HZCG]) {\n    coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.HZCG] = HZCG;\n}\n/* harmony default export */ var converttype_HZCG = (HZCG);\n// CONCATENATED MODULE: ./egova/coordconvert/converttype/WLMQKFQ.js\nvar WLMQKFQ_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction WLMQKFQ_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction WLMQKFQ_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction WLMQKFQ_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\nvar WLMQKFQ = function (_Base) {\n    WLMQKFQ_inherits(WLMQKFQ, _Base);\n\n    function WLMQKFQ(params) {\n        WLMQKFQ_classCallCheck(this, WLMQKFQ);\n\n        var _this = WLMQKFQ_possibleConstructorReturn(this, (WLMQKFQ.__proto__ || Object.getPrototypeOf(WLMQKFQ)).call(this, params));\n\n        _this.DX = 0;\n        _this.DY = 0;\n        _this.T = 0;\n        _this.K = 1;\n        _this.isXYChange = false; //是否需要X与Y对调\n        _this.L0 = 0; //中央经度，弧度\n        if (_this.params) {\n            var pams = _this.params.split(\"#\");\n            _this.DX = parseFloat(pams[0].trim());\n            _this.DY = parseFloat(pams[1].trim());\n            _this.T = parseFloat(pams[2].trim());\n            _this.K = parseFloat(pams[3].trim());\n\n            if (pams.length >= 5) {\n                if (pams[4].trim() == \"1\") {\n                    _this.isXYChange = true;\n                }\n            }\n            if (pams.length >= 6) {\n                _this.L0 = parseFloat(pams[5].trim());\n            }\n        }\n        return _this;\n    }\n\n    /**\r\n     * 将经纬度转换为乌鲁木齐开发区坐标\r\n     * @param lon\r\n     * @param lat\r\n     * @returns {*[]}\r\n     */\n\n\n    WLMQKFQ_createClass(WLMQKFQ, [{\n        key: 'convert',\n        value: function convert(lon, lat) {\n            var B = this.getRad(lat);\n            var L = this.getRad(lon);\n            var cos2b = Math.pow(Math.cos(B), 2);\n            var a0 = 32144.5189 - (135.3646 - (0.7034 - 0.0041 * cos2b) * cos2b) * cos2b;\n            var a4 = (0.25 + 0.00253 * cos2b) * cos2b - 0.04167;\n            var a6 = (0.167 * cos2b - 0.083) * cos2b;\n            var a3 = (0.3333333 + 0.001123 * cos2b) * cos2b - 0.1666667;\n            var a5 = 0.00878 - (0.1702 - 0.20382 * cos2b) * cos2b;\n\n            var N = 6399596.652 - (21562.267 - (109.003 - (0.612 - 0.004 * cos2b) * cos2b) * cos2b) * cos2b;\n            if (this.L0 == 0) {\n                this.L0 = this.getMeridian(L) / 180 * Math.PI;\n            }\n            //var p = 0.0;\n\n            var l = L - this.L0; // p;\n            var l2 = l * l;\n            var x = 6367558.4969 * B // p\n            - (a0 - (0.5 + (a4 + a6 * l2) * l2) * l2 * N) * Math.sin(B) * Math.cos(B);\n            var y = N * Math.cos(B) * (1 + (a3 + a5 * l2) * l2) * l;\n\n            var resultX, resultY;\n            if (this.isXYChange) {\n                //按现场实际情况，对调xy坐标\n                resultY = this.DX + this.K * (x * Math.cos(this.T) - y * Math.sin(this.T));\n                resultX = this.DY + this.K * (x * Math.sin(this.T) + y * Math.cos(this.T));\n            } else {\n                resultX = this.DX + this.K * (x * Math.cos(this.T) - y * Math.sin(this.T));\n                resultY = this.DY + this.K * (x * Math.sin(this.T) + y * Math.cos(this.T));\n            }\n            return [resultX, resultY];\n        }\n\n        /**\r\n         * 获取弧度\r\n         * @param d\r\n         * @returns {number}\r\n         */\n\n    }, {\n        key: 'getRad',\n        value: function getRad(d) {\n            return d / 180 * Math.PI;\n        }\n\n        /**\r\n         * 获取3度带中央子午线\r\n         * @return {number}\r\n         */\n\n    }, {\n        key: 'getMeridian',\n        value: function getMeridian(val2) {\n            if (val2 < 0) {\n                return -1;\n            }\n            var L1 = val2 * 180 / Math.PI;\n            var L2 = parseInt(L1.toString());\n            var left = L1 - L2;\n            var num = L2 / 3;\n            left += L2 % 3;\n            if (left >= 1.5) num++;\n            return num * 3;\n        }\n    }]);\n\n    return WLMQKFQ;\n}(converttype_Base);\n\nif (!coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.WLMQKFQ]) {\n    coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.WLMQKFQ] = WLMQKFQ;\n}\n/* harmony default export */ var converttype_WLMQKFQ = (WLMQKFQ);\n// CONCATENATED MODULE: ./egova/coordconvert/converttype/FZCG.js\nvar FZCG_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction FZCG_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction FZCG_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction FZCG_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\nvar FZCG = function (_Base) {\n    FZCG_inherits(FZCG, _Base);\n\n    function FZCG(params) {\n        FZCG_classCallCheck(this, FZCG);\n\n        return FZCG_possibleConstructorReturn(this, (FZCG.__proto__ || Object.getPrototypeOf(FZCG)).call(this, params));\n    }\n\n    /**\r\n     * 将经纬度转换为福州城管坐标\r\n     * @param lon\r\n     * @param lat\r\n     * @returns {*[]}\r\n     */\n\n\n    FZCG_createClass(FZCG, [{\n        key: 'convert',\n        value: function convert(lon, lat) {\n            return [lon, lat];\n        }\n    }]);\n\n    return FZCG;\n}(converttype_Base);\n\nif (!coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.FZCG]) {\n    coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.FZCG] = FZCG;\n}\n/* harmony default export */ var converttype_FZCG = (FZCG);\n// CONCATENATED MODULE: ./egova/coordconvert/converttype/CSCG.js\nvar CSCG_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction CSCG_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction CSCG_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction CSCG_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\nvar CSCG = function (_Base) {\n    CSCG_inherits(CSCG, _Base);\n\n    function CSCG(params) {\n        CSCG_classCallCheck(this, CSCG);\n\n        var _this = CSCG_possibleConstructorReturn(this, (CSCG.__proto__ || Object.getPrototypeOf(CSCG)).call(this, params));\n\n        _this.a = 0;\n        _this.f = 0;\n        _this.e2 = 0;\n        _this.e12 = 0;\n        _this.A1 = 0;\n        _this.A2 = 0;\n        _this.A3 = 0;\n        _this.A4 = 0;\n        _this.L0 = 112.5;\n        return _this;\n    }\n\n    /**\r\n     * 将经纬度转换为长沙城管坐标\r\n     * @param lon\r\n     * @param lat\r\n     * @returns {*[]}\r\n     */\n\n\n    CSCG_createClass(CSCG, [{\n        key: 'convert',\n        value: function convert(lon, lat) {\n            this.PrjPoint_Krasovsky();\n            var p = 206264.8;\n            var L0 = 108;\n            var L = (lon - L0) * 3600 / p;\n            var L2 = L * L;\n            var radB = lat * Math.PI / 180;\n            var radL = lon * Math.PI / 180;\n            var Bs = lat * 3600;\n            var cosB = Math.cos(radB);\n            var sinB = Math.sin(radB);\n            var cos2B = cosB * cosB;\n\n            var a0 = 32140.404 - (135.3302 - (0.7092 - 0.004 * cos2B) * cos2B) * cos2B;\n            var a3 = (0.3333333 + 0.001123 * cos2B) * cos2B - 0.1666667;\n            var a4 = (0.25 + 0.00252 * cos2B) * cos2B - 0.04166;\n            var a5 = 0.0083 - (0.1667 - (0.1968 + 0.004 * cos2B) * cos2B) * cos2B;\n            var a6 = (0.166 * cos2B - 0.084) * cos2B;\n\n            var N = 6399698.902 - (21562.267 - (108.973 - 0.612 * cos2B) * cos2B) * cos2B;\n\n            var part1 = 6367558.4969 * lat * 3600 / p;\n            var part2 = (a4 + a6 * L2) * L2;\n            var part3 = (0.5 + part2) * L2 * N;\n            var part4 = (a0 - part3) * sinB * cosB;\n            var part5 = (a0 - (0.5 + (a4 + a6 * L2) * L2) * L2 * N) * sinB * cosB;\n            var x1 = 6367558.4969 * lat * 3600 / p - (a0 - (0.5 + (a4 + a6 * L2) * L2) * L2 * N) * sinB * cosB;\n            var y1 = (1 + (a3 + a5 * L2) * L2) * L * N * cosB;\n            if (y1 < 0) {\n                y1 += 500000;\n            }\n            return this.trans(x1, y1);\n        }\n    }, {\n        key: 'PrjPoint_IUGG1975',\n        value: function PrjPoint_IUGG1975() {\n            this.a = 6378140;\n            this.f = 298.257;\n            this.e2 = 1 - (this.f - 1) / this.f * ((this.f - 1) / this.f);\n            this.e12 = this.f / (this.f - 1) * (this.f / (this.f - 1)) - 1;\n            this.A1 = 111133.0047;\n            this.A2 = -16038.5282;\n            this.A3 = 16.8326;\n            this.A4 = -0.0220;\n        }\n    }, {\n        key: 'PrjPoint_Krasovsky',\n        value: function PrjPoint_Krasovsky() {\n            this.a = 6378245;\n            this.f = 298.3;\n            this.e2 = 1 - (this.f - 1) / this.f * ((this.f - 1) / this.f);\n            this.e12 = this.f / (this.f - 1) * (this.f / (this.f - 1)) - 1;\n            this.A1 = 111134.8611;\n            this.A2 = -16036.4803;\n            this.A3 = 16.8281;\n            this.A4 = -0.0220;\n        }\n    }, {\n        key: 'trans',\n        value: function trans(xOld, yOld) {\n            var x0 = -3020366.0078;\n            var y0 = -36557.8676;\n            var k = -38.2363475189;\n\n            var aipha = -0.706823488055555 * Math.PI / 180;\n\n            //根据现场要求对调X,Y坐标.\n            var xNew = x0 + (1 + k / 1000000) * (xOld * Math.cos(aipha) + yOld * Math.sin(aipha));\n            var yNew = y0 + (1 + k / 1000000) * (-xOld * Math.sin(aipha) + yOld * Math.cos(aipha));\n\n            return [yNew, xNew];\n        }\n    }]);\n\n    return CSCG;\n}(converttype_Base);\n\nif (!coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.CSCG]) {\n    coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.CSCG] = CSCG;\n}\n/* harmony default export */ var converttype_CSCG = (CSCG);\n// CONCATENATED MODULE: ./egova/coordconvert/converttype/LZCG.js\nvar LZCG_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction LZCG_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction LZCG_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction LZCG_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\nvar LZCG = function (_Base) {\n    LZCG_inherits(LZCG, _Base);\n\n    function LZCG(params) {\n        LZCG_classCallCheck(this, LZCG);\n\n        var _this = LZCG_possibleConstructorReturn(this, (LZCG.__proto__ || Object.getPrototypeOf(LZCG)).call(this, params));\n\n        _this.isXYChange = false;\n        _this.x0 = -3943744;\n        _this.y0 = -297082;\n        _this.A = 0.999999;\n        _this.B = -0.012005;\n        _this.a = 1;\n        _this.f = 0.0;\n        _this.e2 = 0.0;\n        _this.e12 = 0.0;\n        _this.A1 = 0.0;\n        _this.A2 = 0.0;\n        _this.A3 = 0.0;\n        _this.A4 = 0.0;\n        _this.x = 0.0;\n        _this.y = 0.0;\n        _this.L0 = 117;\n        if (_this.params) {\n            var pams = _this.params.split(\"#\");\n            _this.x0 = parseFloat(pams[0].trim());\n            _this.y0 = parseFloat(pams[1].trim());\n            _this.A = parseFloat(pams[2].trim());\n            _this.B = parseFloat(pams[3].trim());\n\n            if (pams.length >= 5) {\n                if (pams[4].trim() == \"1\") _this.isXYChange = true;\n            }\n        }\n        return _this;\n    }\n\n    /**\r\n     * 将经纬度转换为兰州城管坐标\r\n     * @param lon\r\n     * @param lat\r\n     * @returns {*[]}\r\n     */\n\n\n    LZCG_createClass(LZCG, [{\n        key: 'convert',\n        value: function convert(lon, lat) {\n            var p = 206264.8;\n            var L0 = 105;\n            var L = (lon - L0) * 3600 / p;\n            var L2 = L * L;\n            var radB = lat * Math.PI / 180;\n            var radL = lon * Math.PI / 180;\n            var Bs = lat * 3600;\n            var cosB = Math.cos(radB);\n            var sinB = Math.sin(radB);\n            var cos2B = cosB * cosB;\n\n            var a0 = 32140.404 - (135.3302 - (0.7092 - 0.004 * cos2B) * cos2B) * cos2B;\n            var a3 = (0.3333333 + 0.001123 * cos2B) * cos2B - 0.1666667;\n            var a4 = (0.25 + 0.00252 * cos2B) * cos2B - 0.04166;\n            var a5 = 0.0083 - (0.1667 - (0.1968 + 0.004 * cos2B) * cos2B) * cos2B;\n            var a6 = (0.166 * cos2B - 0.084) * cos2B;\n            var N = 6399698.902 - (21562.267 - (108.973 - 0.612 * cos2B) * cos2B) * cos2B;\n\n            var x1 = 6367558.4969 * (lat * 3600 / p) - (a0 - (0.5 + (a4 + a6 * L2) * L2) * L2 * N) * sinB * cosB;\n            var y1 = (1 + (a3 + a5 * L2) * L2) * L * N * cosB;\n            if (y1 < 0) {\n                y1 += 500000;\n            }\n            this.trans(x1, y1);\n            return [this.x, this.y];\n        }\n    }, {\n        key: 'trans',\n        value: function trans(xOld, yOld) {\n            var aipha = -0.012005;\n            var xNew = this.x0 + (xOld * this.A - yOld * this.B);\n            var yNew = this.y0 + (xOld * this.B + yOld * this.A);\n            this.x = this.change(yNew);\n            this.y = this.change(xNew);\n            return true;\n        }\n\n        /**\r\n         * 给坐标加一个最高位5.\r\n         */\n\n    }, {\n        key: 'change',\n        value: function change(x) {\n            if (x < 0) {\n                return x * 50;\n            }\n            var temp = x / 10;\n            var count = 1;\n            while (parseInt(temp) != 0) {\n                temp = temp / 10;\n                count++;\n            }\n            temp = temp + 5;\n            for (var i = 0; i < count; i++) {\n                temp = temp * 10;\n            }\n            return temp;\n        }\n    }]);\n\n    return LZCG;\n}(converttype_Base);\n\nif (!coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.LZCG]) {\n    coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.LZCG] = LZCG;\n}\n/* harmony default export */ var converttype_LZCG = (LZCG);\n// CONCATENATED MODULE: ./egova/coordconvert/converttype/SYCG.js\nvar SYCG_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction SYCG_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction SYCG_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction SYCG_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\nvar SYCG = function (_Base) {\n    SYCG_inherits(SYCG, _Base);\n\n    function SYCG(params) {\n        SYCG_classCallCheck(this, SYCG);\n\n        var _this = SYCG_possibleConstructorReturn(this, (SYCG.__proto__ || Object.getPrototypeOf(SYCG)).call(this, params));\n\n        _this.A0 = 0.0;\n        _this.A1 = 1.0;\n        _this.A2 = 0.0;\n        _this.B0 = 0.0;\n        _this.B1 = 0.0;\n        _this.B2 = 1.0;\n        _this.isXYChange = false;\n        if (_this.params) {\n            var pams = _this.params.split(\"#\");\n            _this.A0 = parseFloat(pams[0].trim());\n            _this.A1 = parseFloat(pams[1].trim());\n            _this.A2 = parseFloat(pams[2].trim());\n            _this.B0 = parseFloat(pams[3].trim());\n            _this.B1 = parseFloat(pams[4].trim());\n            _this.B2 = parseFloat(pams[5].trim());\n            if (pams.length >= 7) {\n                if (pams[6].trim() == \"1\") _this.isXYChange = true;\n            }\n        }\n        return _this;\n    }\n\n    /**\r\n     * 将经纬度转换为沈阳城管坐标\r\n     * @param lon\r\n     * @param lat\r\n     * @returns {*[]}\r\n     */\n\n\n    SYCG_createClass(SYCG, [{\n        key: 'convert',\n        value: function convert(lon, lat) {\n            //沈阳脱密后经纬度\n            var resultX = this.A0 + this.A1 * lon + this.A2 * lat;\n            var resultY = this.B0 + this.B1 * lon + this.B2 * lat;\n            var result = this.isXYChange ? [resultY, resultX] : [resultX, resultY];\n            return result;\n        }\n    }]);\n\n    return SYCG;\n}(converttype_Base);\n\nif (!coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.SYCG]) {\n    coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.SYCG] = SYCG;\n}\n/* harmony default export */ var converttype_SYCG = (SYCG);\n// CONCATENATED MODULE: ./egova/coordconvert/converttype/WGS84LL2WGS84MC.js\nvar WGS84LL2WGS84MC_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction WGS84LL2WGS84MC_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction WGS84LL2WGS84MC_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction WGS84LL2WGS84MC_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\nvar WGS84LL2WGS84MC = function (_Base) {\n    WGS84LL2WGS84MC_inherits(WGS84LL2WGS84MC, _Base);\n\n    function WGS84LL2WGS84MC(params) {\n        WGS84LL2WGS84MC_classCallCheck(this, WGS84LL2WGS84MC);\n\n        return WGS84LL2WGS84MC_possibleConstructorReturn(this, (WGS84LL2WGS84MC.__proto__ || Object.getPrototypeOf(WGS84LL2WGS84MC)).call(this, params));\n    }\n\n    /**\r\n     * 将WGS84经纬度转换为WGS84墨卡托投影平面坐标\r\n     * @param lon\r\n     * @param lat\r\n     * @returns {*[]}\r\n     */\n\n\n    WGS84LL2WGS84MC_createClass(WGS84LL2WGS84MC, [{\n        key: 'convert',\n        value: function convert(lon, lat) {\n            var x = lon * 20037508.34 / 180;\n            var y = Math.log(Math.tan((90 + lat) * Math.PI / 360)) / (Math.PI / 180);\n            y = y * 20037508.34 / 180;\n            return [x, y];\n        }\n    }]);\n\n    return WGS84LL2WGS84MC;\n}(converttype_Base);\n\nif (!coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.WGS84LL_TO_WGS84MC]) {\n    coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.WGS84LL_TO_WGS84MC] = WGS84LL2WGS84MC;\n}\n/* harmony default export */ var converttype_WGS84LL2WGS84MC = (WGS84LL2WGS84MC);\n// CONCATENATED MODULE: ./egova/coordconvert/converttype/WGS84LL2GCJ02LL.js\nvar WGS84LL2GCJ02LL_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction WGS84LL2GCJ02LL_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction WGS84LL2GCJ02LL_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction WGS84LL2GCJ02LL_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\nvar WGS84LL2GCJ02LL = function (_GD) {\n    WGS84LL2GCJ02LL_inherits(WGS84LL2GCJ02LL, _GD);\n\n    function WGS84LL2GCJ02LL(params) {\n        WGS84LL2GCJ02LL_classCallCheck(this, WGS84LL2GCJ02LL);\n\n        return WGS84LL2GCJ02LL_possibleConstructorReturn(this, (WGS84LL2GCJ02LL.__proto__ || Object.getPrototypeOf(WGS84LL2GCJ02LL)).call(this, params));\n    }\n\n    /**\r\n     * 将WGS84经纬度转换为GCJ02经纬度\r\n     * @param lon\r\n     * @param lat\r\n     * @returns {*[]}\r\n     */\n\n\n    WGS84LL2GCJ02LL_createClass(WGS84LL2GCJ02LL, [{\n        key: 'convert',\n        value: function convert(lon, lat) {\n            var gcj02ll = _get(WGS84LL2GCJ02LL.prototype.__proto__ || Object.getPrototypeOf(WGS84LL2GCJ02LL.prototype), 'wgs84ll2gcj02ll', this).call(this, lon, lat);\n            return gcj02ll;\n        }\n    }]);\n\n    return WGS84LL2GCJ02LL;\n}(converttype_GD);\n\nif (!coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.WGS84LL_TO_GCJ02LL]) {\n    coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.WGS84LL_TO_GCJ02LL] = WGS84LL2GCJ02LL;\n}\n/* harmony default export */ var converttype_WGS84LL2GCJ02LL = (WGS84LL2GCJ02LL);\n// CONCATENATED MODULE: ./egova/coordconvert/converttype/WGS84LL2BDLL.js\nvar WGS84LL2BDLL_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar WGS84LL2BDLL_get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction WGS84LL2BDLL_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction WGS84LL2BDLL_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction WGS84LL2BDLL_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\nvar WGS84LL2BDLL = function (_GD) {\n    WGS84LL2BDLL_inherits(WGS84LL2BDLL, _GD);\n\n    function WGS84LL2BDLL(params) {\n        WGS84LL2BDLL_classCallCheck(this, WGS84LL2BDLL);\n\n        return WGS84LL2BDLL_possibleConstructorReturn(this, (WGS84LL2BDLL.__proto__ || Object.getPrototypeOf(WGS84LL2BDLL)).call(this, params));\n    }\n\n    /**\r\n     * 将WGS84经纬度转换为百度经纬度\r\n     * @param lon\r\n     * @param lat\r\n     * @returns {*[]}\r\n     */\n\n\n    WGS84LL2BDLL_createClass(WGS84LL2BDLL, [{\n        key: 'convert',\n        value: function convert(lon, lat) {\n            var bdll = WGS84LL2BDLL_get(WGS84LL2BDLL.prototype.__proto__ || Object.getPrototypeOf(WGS84LL2BDLL.prototype), 'wgs84ll2bdll', this).call(this, lon, lat);\n            return bdll;\n        }\n    }]);\n\n    return WGS84LL2BDLL;\n}(converttype_GD);\n\nif (!coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.WGS84LL_TO_BDLL]) {\n    coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.WGS84LL_TO_BDLL] = WGS84LL2BDLL;\n}\n/* harmony default export */ var converttype_WGS84LL2BDLL = (WGS84LL2BDLL);\n// CONCATENATED MODULE: ./egova/coordconvert/converttype/WGS84LL2CITY.js\nvar WGS84LL2CITY_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction WGS84LL2CITY_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction WGS84LL2CITY_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction WGS84LL2CITY_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\nvar WGS84LL2CITY_WGS84LL2CITY = function (_Base) {\n    WGS84LL2CITY_inherits(WGS84LL2CITY, _Base);\n\n    function WGS84LL2CITY(params) {\n        WGS84LL2CITY_classCallCheck(this, WGS84LL2CITY);\n\n        var _this = WGS84LL2CITY_possibleConstructorReturn(this, (WGS84LL2CITY.__proto__ || Object.getPrototypeOf(WGS84LL2CITY)).call(this, params));\n\n        var parmArr = params.split(\",\");\n        _this.type = parmArr[0];\n        _this.params = parmArr[1];\n        _this.wgs842xyFactory = getConvertFactory(_this.type, _this.params);\n        return _this;\n    }\n\n    /**\r\n     * wgs84经纬度转城市平面\r\n     * @param x\r\n     * @param y\r\n     */\n\n\n    WGS84LL2CITY_createClass(WGS84LL2CITY, [{\n        key: 'convert',\n        value: function convert(lon, lat) {\n            var xy = this.wgs842xyFactory.convert(lon, lat);\n            return xy;\n        }\n    }]);\n\n    return WGS84LL2CITY;\n}(converttype_Base);\n\nif (!coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.WGS84LL_TO_CITY]) {\n    coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.WGS84LL_TO_CITY] = WGS84LL2CITY_WGS84LL2CITY;\n}\n/* harmony default export */ var converttype_WGS84LL2CITY = (WGS84LL2CITY_WGS84LL2CITY);\n// CONCATENATED MODULE: ./egova/coordconvert/converttype/WGS84MC2WGS84LL.js\nvar WGS84MC2WGS84LL_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction WGS84MC2WGS84LL_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction WGS84MC2WGS84LL_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction WGS84MC2WGS84LL_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\nvar WGS84MC2WGS84LL = function (_Base) {\n    WGS84MC2WGS84LL_inherits(WGS84MC2WGS84LL, _Base);\n\n    function WGS84MC2WGS84LL(params) {\n        WGS84MC2WGS84LL_classCallCheck(this, WGS84MC2WGS84LL);\n\n        return WGS84MC2WGS84LL_possibleConstructorReturn(this, (WGS84MC2WGS84LL.__proto__ || Object.getPrototypeOf(WGS84MC2WGS84LL)).call(this, params));\n    }\n\n    /**\r\n     * 墨卡托米制反转WGS84经纬度\r\n     * @param x\r\n     * @param y\r\n     */\n\n\n    WGS84MC2WGS84LL_createClass(WGS84MC2WGS84LL, [{\n        key: 'convert',\n        value: function convert(x, y) {\n            var lon = x / 20037508.3427892 * 180;\n            var lat = y / 20037508.3427892 * 180;\n            lat = 180 / Math.PI * (2 * Math.atan(Math.exp(lat * Math.PI / 180)) - Math.PI / 2);\n\n            return [lon, lat];\n        }\n    }]);\n\n    return WGS84MC2WGS84LL;\n}(converttype_Base);\n\nif (!coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.WGS84MC_TO_WGS84LL]) {\n    coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.WGS84MC_TO_WGS84LL] = WGS84MC2WGS84LL;\n}\n/* harmony default export */ var converttype_WGS84MC2WGS84LL = (WGS84MC2WGS84LL);\n// CONCATENATED MODULE: ./egova/coordconvert/converttype/GCJ02LL2WGS84LL.js\nvar GCJ02LL2WGS84LL_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar GCJ02LL2WGS84LL_get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction GCJ02LL2WGS84LL_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction GCJ02LL2WGS84LL_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction GCJ02LL2WGS84LL_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\nvar GCJ02LL2WGS84LL = function (_GD) {\n    GCJ02LL2WGS84LL_inherits(GCJ02LL2WGS84LL, _GD);\n\n    function GCJ02LL2WGS84LL(params) {\n        GCJ02LL2WGS84LL_classCallCheck(this, GCJ02LL2WGS84LL);\n\n        return GCJ02LL2WGS84LL_possibleConstructorReturn(this, (GCJ02LL2WGS84LL.__proto__ || Object.getPrototypeOf(GCJ02LL2WGS84LL)).call(this, params));\n    }\n\n    /**\r\n     * 将GCJ02经纬度转换为wgs经纬度\r\n     * @param lon\r\n     * @param lat\r\n     * @returns {*[]}\r\n     */\n\n\n    GCJ02LL2WGS84LL_createClass(GCJ02LL2WGS84LL, [{\n        key: 'convert',\n        value: function convert(lon, lat) {\n            var wgs84ll = GCJ02LL2WGS84LL_get(GCJ02LL2WGS84LL.prototype.__proto__ || Object.getPrototypeOf(GCJ02LL2WGS84LL.prototype), 'gcj02ll2wgs84ll', this).call(this, lon, lat);\n            return wgs84ll;\n        }\n    }]);\n\n    return GCJ02LL2WGS84LL;\n}(converttype_GD);\n\nif (!coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.GCJ02LL_TO_WGS84LL]) {\n    coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.GCJ02LL_TO_WGS84LL] = GCJ02LL2WGS84LL;\n}\n/* harmony default export */ var converttype_GCJ02LL2WGS84LL = (GCJ02LL2WGS84LL);\n// CONCATENATED MODULE: ./egova/coordconvert/converttype/GCJ02LL2GCJ02MC.js\nvar GCJ02LL2GCJ02MC_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar GCJ02LL2GCJ02MC_get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction GCJ02LL2GCJ02MC_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction GCJ02LL2GCJ02MC_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction GCJ02LL2GCJ02MC_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\nvar GCJ02LL2GCJ02MC = function (_GD) {\n    GCJ02LL2GCJ02MC_inherits(GCJ02LL2GCJ02MC, _GD);\n\n    function GCJ02LL2GCJ02MC(params) {\n        GCJ02LL2GCJ02MC_classCallCheck(this, GCJ02LL2GCJ02MC);\n\n        return GCJ02LL2GCJ02MC_possibleConstructorReturn(this, (GCJ02LL2GCJ02MC.__proto__ || Object.getPrototypeOf(GCJ02LL2GCJ02MC)).call(this, params));\n    }\n\n    /**\r\n     * 将GCJ02经纬度转换为GCJ02MC\r\n     * @param lon\r\n     * @param lat\r\n     * @returns {*[]}\r\n     */\n\n\n    GCJ02LL2GCJ02MC_createClass(GCJ02LL2GCJ02MC, [{\n        key: 'convert',\n        value: function convert(lon, lat) {\n            var gcj02mc = GCJ02LL2GCJ02MC_get(GCJ02LL2GCJ02MC.prototype.__proto__ || Object.getPrototypeOf(GCJ02LL2GCJ02MC.prototype), 'latLon2Mercator', this).call(this, lat, lon);\n            return gcj02mc;\n        }\n    }]);\n\n    return GCJ02LL2GCJ02MC;\n}(converttype_GD);\n\nif (!coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.GCJ02LL_TO_GCJ02MC]) {\n    coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.GCJ02LL_TO_GCJ02MC] = GCJ02LL2GCJ02MC;\n}\n/* harmony default export */ var converttype_GCJ02LL2GCJ02MC = (GCJ02LL2GCJ02MC);\n// CONCATENATED MODULE: ./egova/coordconvert/converttype/GCJ02LL2BDLL.js\nvar GCJ02LL2BDLL_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar GCJ02LL2BDLL_get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction GCJ02LL2BDLL_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction GCJ02LL2BDLL_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction GCJ02LL2BDLL_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\nvar GCJ02LL2BDLL = function (_GD) {\n    GCJ02LL2BDLL_inherits(GCJ02LL2BDLL, _GD);\n\n    function GCJ02LL2BDLL(params) {\n        GCJ02LL2BDLL_classCallCheck(this, GCJ02LL2BDLL);\n\n        return GCJ02LL2BDLL_possibleConstructorReturn(this, (GCJ02LL2BDLL.__proto__ || Object.getPrototypeOf(GCJ02LL2BDLL)).call(this, params));\n    }\n\n    /**\r\n     * GCJ02经纬度转百度经纬度\r\n     * @param x\r\n     * @param y\r\n     * @returns {*}\r\n     */\n\n\n    GCJ02LL2BDLL_createClass(GCJ02LL2BDLL, [{\n        key: 'convert',\n        value: function convert(lon, lat) {\n            var bdll = GCJ02LL2BDLL_get(GCJ02LL2BDLL.prototype.__proto__ || Object.getPrototypeOf(GCJ02LL2BDLL.prototype), 'gcj02ll2bdll', this).call(this, lon, lat);\n            return bdll;\n        }\n    }]);\n\n    return GCJ02LL2BDLL;\n}(converttype_GD);\n\nif (!coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.GCJ02LL_TO_BDLL]) {\n    coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.GCJ02LL_TO_BDLL] = GCJ02LL2BDLL;\n}\n/* harmony default export */ var converttype_GCJ02LL2BDLL = (GCJ02LL2BDLL);\n// CONCATENATED MODULE: ./egova/coordconvert/converttype/GCJ02MC2GCJ02LL.js\nvar GCJ02MC2GCJ02LL_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar GCJ02MC2GCJ02LL_get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction GCJ02MC2GCJ02LL_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction GCJ02MC2GCJ02LL_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction GCJ02MC2GCJ02LL_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\nvar GCJ02MC2GCJ02LL = function (_GD) {\n    GCJ02MC2GCJ02LL_inherits(GCJ02MC2GCJ02LL, _GD);\n\n    function GCJ02MC2GCJ02LL(params) {\n        GCJ02MC2GCJ02LL_classCallCheck(this, GCJ02MC2GCJ02LL);\n\n        return GCJ02MC2GCJ02LL_possibleConstructorReturn(this, (GCJ02MC2GCJ02LL.__proto__ || Object.getPrototypeOf(GCJ02MC2GCJ02LL)).call(this, params));\n    }\n\n    /**\r\n     * 将GCJ02平面坐标转换为GCJ02经纬度\r\n     * @param x\r\n     * @param y\r\n     * @returns {*[]}\r\n     */\n\n\n    GCJ02MC2GCJ02LL_createClass(GCJ02MC2GCJ02LL, [{\n        key: 'convert',\n        value: function convert(x, y) {\n            var gcj02ll = GCJ02MC2GCJ02LL_get(GCJ02MC2GCJ02LL.prototype.__proto__ || Object.getPrototypeOf(GCJ02MC2GCJ02LL.prototype), 'mercator2LatLon', this).call(this, x, y);\n            return gcj02ll;\n        }\n    }]);\n\n    return GCJ02MC2GCJ02LL;\n}(converttype_GD);\n\nif (!coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.GCJ02MC_TO_GCJ02LL]) {\n    coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.GCJ02MC_TO_GCJ02LL] = GCJ02MC2GCJ02LL;\n}\n/* harmony default export */ var converttype_GCJ02MC2GCJ02LL = (GCJ02MC2GCJ02LL);\n// CONCATENATED MODULE: ./egova/coordconvert/converttype/BDLL2WGS84LL.js\nvar BDLL2WGS84LL_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar BDLL2WGS84LL_get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction BDLL2WGS84LL_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction BDLL2WGS84LL_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction BDLL2WGS84LL_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\nvar BDLL2WGS84LL = function (_GD) {\n    BDLL2WGS84LL_inherits(BDLL2WGS84LL, _GD);\n\n    function BDLL2WGS84LL(params) {\n        BDLL2WGS84LL_classCallCheck(this, BDLL2WGS84LL);\n\n        return BDLL2WGS84LL_possibleConstructorReturn(this, (BDLL2WGS84LL.__proto__ || Object.getPrototypeOf(BDLL2WGS84LL)).call(this, params));\n    }\n\n    /**\r\n     * 将百度经纬度坐标转换为wgs84经纬度\r\n     * @param lon\r\n     * @param lat\r\n     * @returns {*[]}\r\n     */\n\n\n    BDLL2WGS84LL_createClass(BDLL2WGS84LL, [{\n        key: 'convert',\n        value: function convert(lon, lat) {\n            var wgs84ll = BDLL2WGS84LL_get(BDLL2WGS84LL.prototype.__proto__ || Object.getPrototypeOf(BDLL2WGS84LL.prototype), 'bdll2wgs84ll', this).call(this, lon, lat);\n            return wgs84ll;\n        }\n    }]);\n\n    return BDLL2WGS84LL;\n}(converttype_GD);\n\nif (!coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.BDLL_TO_WGS84LL]) {\n    coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.BDLL_TO_WGS84LL] = BDLL2WGS84LL;\n}\n/* harmony default export */ var converttype_BDLL2WGS84LL = (BDLL2WGS84LL);\n// CONCATENATED MODULE: ./egova/coordconvert/converttype/BDLL2GCJ02LL.js\nvar BDLL2GCJ02LL_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar BDLL2GCJ02LL_get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction BDLL2GCJ02LL_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction BDLL2GCJ02LL_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction BDLL2GCJ02LL_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\nvar BDLL2GCJ02LL = function (_GD) {\n    BDLL2GCJ02LL_inherits(BDLL2GCJ02LL, _GD);\n\n    function BDLL2GCJ02LL(params) {\n        BDLL2GCJ02LL_classCallCheck(this, BDLL2GCJ02LL);\n\n        return BDLL2GCJ02LL_possibleConstructorReturn(this, (BDLL2GCJ02LL.__proto__ || Object.getPrototypeOf(BDLL2GCJ02LL)).call(this, params));\n    }\n\n    /**\r\n     * 将百度经纬度坐标转换为GCJ02经纬度\r\n     * @param lon\r\n     * @param lat\r\n     * @returns {*[]}\r\n     */\n\n\n    BDLL2GCJ02LL_createClass(BDLL2GCJ02LL, [{\n        key: 'convert',\n        value: function convert(lon, lat) {\n            var gcjo2ll = BDLL2GCJ02LL_get(BDLL2GCJ02LL.prototype.__proto__ || Object.getPrototypeOf(BDLL2GCJ02LL.prototype), 'bdll2gcjll', this).call(this, lat, lon);\n            return gcjo2ll;\n        }\n    }]);\n\n    return BDLL2GCJ02LL;\n}(converttype_GD);\n\nif (!coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.BDLL_TO_GCJ02LL]) {\n    coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.BDLL_TO_GCJ02LL] = BDLL2GCJ02LL;\n}\n/* harmony default export */ var converttype_BDLL2GCJ02LL = (BDLL2GCJ02LL);\n// CONCATENATED MODULE: ./egova/coordconvert/converttype/BDLL2BDMC.js\nvar BDLL2BDMC_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar BDLL2BDMC_get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction BDLL2BDMC_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction BDLL2BDMC_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction BDLL2BDMC_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\nvar BDLL2BDMC = function (_BD) {\n    BDLL2BDMC_inherits(BDLL2BDMC, _BD);\n\n    function BDLL2BDMC(params) {\n        BDLL2BDMC_classCallCheck(this, BDLL2BDMC);\n\n        return BDLL2BDMC_possibleConstructorReturn(this, (BDLL2BDMC.__proto__ || Object.getPrototypeOf(BDLL2BDMC)).call(this, params));\n    }\n\n    /**\r\n     * 将百度经纬度坐标转换为百度米制\r\n     * @param lon\r\n     * @param lat\r\n     * @returns {*[]}\r\n     */\n\n\n    BDLL2BDMC_createClass(BDLL2BDMC, [{\n        key: 'convert',\n        value: function convert(lon, lat) {\n            var bdmc = BDLL2BDMC_get(BDLL2BDMC.prototype.__proto__ || Object.getPrototypeOf(BDLL2BDMC.prototype), 'bdll2bdmc', this).call(this, lon, lat);\n            return bdmc;\n        }\n    }]);\n\n    return BDLL2BDMC;\n}(converttype_BD);\n\nif (!coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.BDLL_TO_BDMC]) {\n    coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.BDLL_TO_BDMC] = BDLL2BDMC;\n}\n/* harmony default export */ var converttype_BDLL2BDMC = (BDLL2BDMC);\n// CONCATENATED MODULE: ./egova/coordconvert/converttype/BDMC2BDLL.js\nvar BDMC2BDLL_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar BDMC2BDLL_get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction BDMC2BDLL_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction BDMC2BDLL_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction BDMC2BDLL_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\nvar BDMC2BDLL = function (_BD) {\n    BDMC2BDLL_inherits(BDMC2BDLL, _BD);\n\n    function BDMC2BDLL(params) {\n        BDMC2BDLL_classCallCheck(this, BDMC2BDLL);\n\n        return BDMC2BDLL_possibleConstructorReturn(this, (BDMC2BDLL.__proto__ || Object.getPrototypeOf(BDMC2BDLL)).call(this, params));\n    }\n\n    /**\r\n     * 将百度米制坐标转换为百度经纬度\r\n     * @param x\r\n     * @param y\r\n     * @returns {*[]}\r\n     */\n\n\n    BDMC2BDLL_createClass(BDMC2BDLL, [{\n        key: 'convert',\n        value: function convert(x, y) {\n            var bdll = BDMC2BDLL_get(BDMC2BDLL.prototype.__proto__ || Object.getPrototypeOf(BDMC2BDLL.prototype), 'bdmc2bdll', this).call(this, x, y);\n            return bdll;\n        }\n    }]);\n\n    return BDMC2BDLL;\n}(converttype_BD);\n\nif (!coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.BDMC_TO_BDLL]) {\n    coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.BDMC_TO_BDLL] = BDMC2BDLL;\n}\n/* harmony default export */ var converttype_BDMC2BDLL = (BDMC2BDLL);\n// CONCATENATED MODULE: ./egova/coordconvert/converttype/CITY2WGS84LL4Parms.js\nvar CITY2WGS84LL4Parms_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction CITY2WGS84LL4Parms_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction CITY2WGS84LL4Parms_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction CITY2WGS84LL4Parms_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\nvar CITY2WGS84LL4Parms = function (_Base) {\n    CITY2WGS84LL4Parms_inherits(CITY2WGS84LL4Parms, _Base);\n\n    function CITY2WGS84LL4Parms(params) {\n        CITY2WGS84LL4Parms_classCallCheck(this, CITY2WGS84LL4Parms);\n\n        var _this = CITY2WGS84LL4Parms_possibleConstructorReturn(this, (CITY2WGS84LL4Parms.__proto__ || Object.getPrototypeOf(CITY2WGS84LL4Parms)).call(this, params));\n\n        _this.deltaX = 0;\n        _this.deltaY = 0;\n        _this.ax = 0;\n        _this.scale = 0;\n        _this.isXYChange = false; //是否需要X与Y对调\n        _this.centerLon = 0; //中央经度\n        if (params) {\n            var pams = _this.params.split(\"#\");\n            _this.deltaX = parseFloat(pams[0].trim());\n            _this.deltaY = parseFloat(pams[1].trim());\n            _this.ax = parseFloat(pams[2].trim());\n            _this.scale = parseFloat(pams[3].trim());\n\n            if (pams.length >= 5) {\n                if (pams[4].trim() == \"1\") _this.isXYChange = true;\n            }\n            if (pams.length >= 6) {\n                _this.centerLon = parseFloat(pams[5].trim());\n            }\n        }\n        return _this;\n    }\n\n    /**\r\n     * YDCL四参数法将城市平面反转为WGS84经纬度\r\n     * @param x\r\n     * @param y\r\n     */\n\n\n    CITY2WGS84LL4Parms_createClass(CITY2WGS84LL4Parms, [{\n        key: \"convert\",\n        value: function convert(x, y) {\n            var originX = x;\n            var originY = y;\n            if (this.isXYChange) {\n                originX = y;\n                originY = x;\n            }\n            //利用4参数求新坐标系的坐标\n            var k = this.scale;\n            var a1 = k * Math.cos(this.ax);\n            var a2 = k * Math.sin(this.ax);\n            var toX = this.deltaX + a1 * originX + a2 * originY;\n            var toY = this.deltaY + a1 * originY - a2 * originX;\n\n            var ProjNo, ZoneWide; ////带宽\n            var l, b, longitude0, X0, xval, yval, lon;\n            var e1, e2, f, a, ee, NN, T, C, M, D, R, u, fai;\n            a = 6378137; //54年北京坐标系参数\n            ZoneWide = 3; //3度带宽\n            ProjNo = parseInt(toX / 1000000); //查找带号\n            lon = this.centerLon;\n            longitude0 = lon;\n            if (Math.abs(lon - 0) < 0.000001) {\n                longitude0 = ProjNo * ZoneWide; //中央经线\n            }\n            longitude0 = longitude0 * Math.PI / 180; //中央经线\n            X0 = ProjNo * 1000000 + 500000;\n            xval = toX - X0; //带内大地坐标\n            yval = toY;\n            e2 = 0.00669437999013;\n            e1 = (1.0 - Math.sqrt(1 - e2)) / (1.0 + Math.sqrt(1 - e2));\n            ee = e2 / (1 - e2);\n            M = yval;\n            u = M / (a * (1 - e2 / 4 - 3 * e2 * e2 / 64 - 5 * e2 * e2 * e2 / 256));\n            fai = u + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * u) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * u) + 151 * e1 * e1 * e1 / 96 * Math.sin(6 * u) + 1097 * e1 * e1 * e1 * e1 / 512 * Math.sin(8 * u);\n            C = ee * Math.cos(fai) * Math.cos(fai);\n            T = Math.tan(fai) * Math.tan(fai);\n            NN = a / Math.sqrt(1.0 - e2 * Math.sin(fai) * Math.sin(fai));\n\n            R = a * (1 - e2) / Math.sqrt((1 - e2 * Math.sin(fai) * Math.sin(fai)) * (1 - e2 * Math.sin(fai) * Math.sin(fai)) * (1 - e2 * Math.sin(fai) * Math.sin(fai)));\n            D = xval / NN;\n            //计算经度(Longitude) 纬度(Latitude)\n            l = longitude0 + (D - (1 + 2 * T + C) * D * D * D / 6 + (5 - 2 * C + 28 * T - 3 * C * C + 8 * ee + 24 * T * T) * D * D * D * D * D / 120) / Math.cos(fai);\n            b = fai - NN * Math.tan(fai) / R * (D * D / 2 - (5 + 3 * T + 10 * C - 4 * C * C - 9 * ee) * D * D * D * D / 24 + (61 + 90 * T + 298 * C + 45 * T * T - 256 * ee - 3 * C * C) * D * D * D * D * D * D / 720);\n            //转换为度 DD\n            l = l * 180 / Math.PI;\n            b = b * 180 / Math.PI;\n\n            return [l, b];\n        }\n    }]);\n\n    return CITY2WGS84LL4Parms;\n}(converttype_Base);\n\n/* harmony default export */ var converttype_CITY2WGS84LL4Parms = (CITY2WGS84LL4Parms);\n// CONCATENATED MODULE: ./egova/coordconvert/converttype/CITY2WGS84LLApprox.js\nvar CITY2WGS84LLApprox_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction CITY2WGS84LLApprox_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction CITY2WGS84LLApprox_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction CITY2WGS84LLApprox_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\nvar CITY2WGS84LLApprox_CITY2WGS84LLApprox = function (_Base) {\n    CITY2WGS84LLApprox_inherits(CITY2WGS84LLApprox, _Base);\n\n    function CITY2WGS84LLApprox(params) {\n        CITY2WGS84LLApprox_classCallCheck(this, CITY2WGS84LLApprox);\n\n        //(逼近法)经纬度初始值，默认值为CGCS2000大地原点陕西省泾阳县永乐镇北横流村\n        //具体位置在：北纬34°32′27.00″东经108°55′25.00″。\n        var _this = CITY2WGS84LLApprox_possibleConstructorReturn(this, (CITY2WGS84LLApprox.__proto__ || Object.getPrototypeOf(CITY2WGS84LLApprox)).call(this, params));\n\n        _this.centerLon = 108.9236111;\n        _this.centerLat = 34.54083333;\n        _this.lonPermeter = 0.00000901; //每米代表的实地近似经度，默认值为1/111000，由纬度决定真实值\n        _this.latPermeter = 0.00000901; //每米代表的实地近似纬度，常量值1/111000，即每度111公里\n        var parmArr = params.split(\",\");\n        _this.type = parmArr[0];\n        _this.params = parmArr[1];\n        _this.isXYChange = false;\n        _this.parmsHasCenterLon = false; //转换参数中是否含有中央经线\n        _this.hasParseCeterLonlat = false; //是否已经解析了中央经纬度\n        _this.wgs842xyFactory = null;\n\n        if (_this.params) {\n            var pams = _this.params.split(\"#\");\n            if (pams.length >= 5) {\n                if (pams[4].trim() == \"1\") _this.isXYChange = true;\n            }\n            if (pams.length >= 6) {\n                _this.centerLon = parseFloat(pams[5].trim());\n                _this.lonPermeter = 0.00000901 * Math.abs(Math.cos(_this.centerLat));\n                _this.wgs842xyFactory = getConvertFactory(_this.type, _this.params);\n                _this.parmsHasCenterLon = true;\n            } else {\n                console.info(\"传入的四参数{\" + params + \"}中不含中央经线, 无法执行当地平面反转到WGS84经纬度\");\n                _this.centerLon = 108.9236111;\n                _this.lonPermeter = 0.00000901 * Math.abs(Math.cos(108.9236111));\n                _this.wgs842xyFactory = null;\n                _this.parmsHasCenterLon = false;\n            }\n        }\n        return _this;\n    }\n\n    /**\r\n     * 将城市平面坐标转换为WGS84经纬度坐标--正转四参数法\r\n     * @param x\r\n     * @param y\r\n     */\n\n\n    CITY2WGS84LLApprox_createClass(CITY2WGS84LLApprox, [{\n        key: 'convert',\n        value: function convert(x, y) {\n            //转换参数中不含中央经线，无法转换\n            if (!this.parmsHasCenterLon) {\n                this.hasParseCeterLonlat = false;\n                return [-1, -1];\n            }\n            if (!this.hasParseCeterLonlat) {\n                //未解析出中央经纬度\n                this.centerLat = this.GetNearestLat(x, y, this.centerLon);\n                this.hasParseCeterLonlat = true;\n            }\n\n            //首先获取平面坐标值均小于输入xy坐标的最佳逼近经纬度\n            var approxLowLonlat = this.GetApproxLowLonlat(x, y);\n            var approxLowLon = approxLowLonlat[0];\n            var approxLowLat = approxLowLonlat[1];\n            var approxLowX = approxLowLonlat[2];\n            var approxLowY = approxLowLonlat[3];\n\n            //获取平面坐标值均大于输入xy坐标的最佳逼近经纬度\n            var approxUpperLon = approxLowLon + 0.00001;\n            var approxUpperLat = approxLowLat + 0.00001;\n            var approxUpperXY = this.wgs842xyFactory.convert(approxUpperLon, approxUpperLat);\n            var approxUpperX = approxUpperXY[0];\n            var approxUpperY = approxUpperXY[1];\n            while (approxUpperX < x) {\n                approxUpperLon += 0.00001;\n                approxUpperXY = this.wgs842xyFactory.convert(approxUpperLon, approxUpperLat);\n                approxUpperX = approxUpperXY[0];\n            }\n            while (approxUpperY < y) {\n                approxUpperLat += 0.00001;\n                approxUpperXY = this.wgs842xyFactory.convert(approxUpperLon, approxUpperLat);\n                approxUpperY = approxUpperXY[1];\n            }\n\n            //利用左下和右上角点进行插值\n            var offX = (x - approxLowX) / (approxUpperX - approxLowX);\n            var offY = (y - approxLowY) / (approxUpperY - approxLowY);\n\n            var lon = approxLowLon + offX * (approxUpperLon - approxLowLon);\n            var lat = approxLowLat + offY * (approxUpperLat - approxLowLat);\n\n            this.centerLon = lon;\n            this.centerLat = lat;\n            return [lon, lat];\n        }\n\n        /**\r\n         * 在经度已知的前提下，获取最接近平面坐标对应的真实经纬度的整数纬度\r\n         * @param x\r\n         * @param y\r\n         * @param lon\r\n         * @returns {*}\r\n         */\n\n    }, {\n        key: 'GetNearestLat',\n        value: function GetNearestLat(x, y, lon) {\n            //中国大陆纬度范围：18 - 54\n            var dy;\n            var convertXY;\n            var minKey = 0;\n            var minDy = 0;\n            for (var i = 18; i <= 54; i++) {\n                convertXY = this.wgs842xyFactory.convert(lon, i);\n                dy = Math.abs(convertXY[1] - y);\n                if (i == 18) {\n                    minDy = dy;\n                    minKey = 18;\n                }\n                if (dy < minDy) {\n                    minDy = dy;\n                    minKey = i;\n                }\n            }\n            return minKey;\n        }\n\n        /**\r\n         * 获取最接近输入平面坐标的真实经纬度的近似经纬度和平面坐标，要求近似经纬度值均小于真实经纬度\r\n         * @param x\r\n         * @param y\r\n         * @returns {*[]}\r\n         */\n\n    }, {\n        key: 'GetApproxLowLonlat',\n        value: function GetApproxLowLonlat(x, y) {\n            var orginX = x;\n            var orginY = y;\n\n            //计算中心点经纬度的平面坐标\n            var centerXY = this.wgs842xyFactory.convert(this.centerLon, this.centerLat);\n            var centerX = centerXY[0];\n            var centerY = centerXY[1];\n\n            //获取输入平面坐标的初始近似经纬度坐标\n            var approxLon = this.centerLon + (orginX - centerX - 1) * this.lonPermeter; //-1是为了尽可能从小于真实值方向趋近\n            var approxLat = this.centerLat + (orginY - centerY - 1) * this.latPermeter;\n\n            //近似平面坐标\n            var approxXY = this.wgs842xyFactory.convert(approxLon, approxLat);\n            var approxX = approxXY[0];\n            var approxY = approxXY[1];\n\n            while (approxX > x) {\n                approxLon -= 0.00001;\n                approxXY = this.wgs842xyFactory.convert(approxLon, approxLat);\n                approxX = approxXY[0];\n            }\n            while (x - approxX > 10) {\n                approxLon += 0.0001;\n                approxXY = this.wgs842xyFactory.convert(approxLon, approxLat);\n                approxX = approxXY[0];\n            }\n            while (approxY > y) {\n                approxLat -= 0.00001;\n                approxXY = this.wgs842xyFactory.convert(approxLon, approxLat);\n                approxY = approxXY[1];\n            }\n            while (y - approxY > 10) {\n                approxLat += 0.0001;\n                approxXY = this.wgs842xyFactory.convert(approxLon, approxLat);\n                approxY = approxXY[1];\n            }\n            return [approxLon, approxLat, approxX, approxY];\n        }\n    }]);\n\n    return CITY2WGS84LLApprox;\n}(converttype_Base);\n\n/* harmony default export */ var converttype_CITY2WGS84LLApprox = (CITY2WGS84LLApprox_CITY2WGS84LLApprox);\n// CONCATENATED MODULE: ./egova/coordconvert/converttype/CITY2WGS84LL.js\nvar CITY2WGS84LL_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction CITY2WGS84LL_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction CITY2WGS84LL_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction CITY2WGS84LL_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\n\nvar CITY2WGS84LL_CITY2WGS84LL = function (_Base) {\n    CITY2WGS84LL_inherits(CITY2WGS84LL, _Base);\n\n    function CITY2WGS84LL(params) {\n        CITY2WGS84LL_classCallCheck(this, CITY2WGS84LL);\n\n        var _this = CITY2WGS84LL_possibleConstructorReturn(this, (CITY2WGS84LL.__proto__ || Object.getPrototypeOf(CITY2WGS84LL)).call(this, params));\n\n        _this.convertImp = null;\n        if (params) {\n            var parmArr = params.split(\",\");\n            if (parmArr.length >= 2) {\n                _this.convertImp = new converttype_CITY2WGS84LLApprox(params);\n            } else {\n                _this.convertImp = new converttype_CITY2WGS84LL4Parms(params);\n            }\n        } else {\n            console.info(\"传入的坐标转换参数为空，无法完成转换！\");\n        }\n\n        return _this;\n    }\n\n    /**\r\n     * 城市平面反转WGS84经纬度\r\n     * @param x\r\n     * @param y\r\n     * @returns {*}\r\n     */\n\n\n    CITY2WGS84LL_createClass(CITY2WGS84LL, [{\n        key: 'convert',\n        value: function convert(x, y) {\n            if (!this.params) {\n                return [-1, -1];\n            }\n            var lonlat = this.convertImp.convert(x, y);\n            return lonlat;\n        }\n    }]);\n\n    return CITY2WGS84LL;\n}(converttype_Base);\n\nif (!coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.CITY_TO_WGS84LL]) {\n    coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.CITY_TO_WGS84LL] = CITY2WGS84LL_CITY2WGS84LL;\n}\n/* harmony default export */ var converttype_CITY2WGS84LL = (CITY2WGS84LL_CITY2WGS84LL);\n// CONCATENATED MODULE: ./egova/coordconvert/converttype/BJCG2WGS84LL.js\nvar BJCG2WGS84LL_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction BJCG2WGS84LL_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction BJCG2WGS84LL_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction BJCG2WGS84LL_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\nvar BJCG2WGS84LL = function (_Base) {\n    BJCG2WGS84LL_inherits(BJCG2WGS84LL, _Base);\n\n    function BJCG2WGS84LL(params) {\n        BJCG2WGS84LL_classCallCheck(this, BJCG2WGS84LL);\n\n        var _this = BJCG2WGS84LL_possibleConstructorReturn(this, (BJCG2WGS84LL.__proto__ || Object.getPrototypeOf(BJCG2WGS84LL)).call(this, params));\n\n        _this.A1 = 6103729.01171875;\n        _this.B1 = -158449219.125;\n        _this.C1 = -709804016;\n        _this.D1 = 18920915837.022213;\n        _this.A2 = 7662548.3125;\n        _this.B2 = -305916495;\n        _this.C2 = -780249200;\n        _this.D2 = 31456748837.828285;\n        return _this;\n    }\n\n    /**\r\n     * 将北京城管坐标转换为WGS84经纬度\r\n     * @param originX\r\n     * @param originY\r\n     * @returns {*[]}\r\n     */\n\n\n    BJCG2WGS84LL_createClass(BJCG2WGS84LL, [{\n        key: 'convert',\n        value: function convert(originX, originY) {\n            var y = originY * 1000;\n            var x = originX * 1000;\n            var b = (x - this.D1) * this.A2 - this.B2 * this.C1 - (y - this.D2) * this.A1 + this.B1 * this.C2;\n            var a = this.A1 * this.C2 - this.A2 * this.C1;\n            var c = (x - this.D1) * this.B2 - (y - this.D2) * this.B1;\n            var b2ac = Math.pow(b, 2) - 4 * a * c;\n            var ry = (-b + Math.sqrt(b2ac)) / (2 * a);\n            var rx = (x - this.D1 - this.C1 * ry) / (this.A1 * ry + this.B1);\n            return [rx, ry];\n        }\n    }]);\n\n    return BJCG2WGS84LL;\n}(converttype_Base);\n\nif (!coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.BJCG_TO_WGS84LL]) {\n    coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.BJCG_TO_WGS84LL] = BJCG2WGS84LL;\n}\n/* harmony default export */ var converttype_BJCG2WGS84LL = (BJCG2WGS84LL);\n// CONCATENATED MODULE: ./egova/coordconvert/converttype/6PARAMS.js\nvar _6PARAMS_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _6PARAMS_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _6PARAMS_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _6PARAMS_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\nvar SIX_PARAMS = function (_Base) {\n    _6PARAMS_inherits(SIX_PARAMS, _Base);\n\n    function SIX_PARAMS(params) {\n        _6PARAMS_classCallCheck(this, SIX_PARAMS);\n\n        var _this = _6PARAMS_possibleConstructorReturn(this, (SIX_PARAMS.__proto__ || Object.getPrototypeOf(SIX_PARAMS)).call(this, params));\n\n        _this.a0 = 0;\n        _this.a1 = 1;\n        _this.a2 = 0;\n        _this.b0 = 0;\n        _this.b1 = 0;\n        _this.b2 = 1;\n        if (params) {\n            var pams = params.split(\"#\"); //六参数形如：\"a0#a1#a2#b0#b1#b2\"\n            _this.a0 = parseFloat(pams[0].trim());\n            _this.a1 = parseFloat(pams[1].trim());\n            _this.a2 = parseFloat(pams[2].trim());\n            _this.b0 = parseFloat(pams[3].trim());\n            _this.b1 = parseFloat(pams[4].trim());\n            _this.b2 = parseFloat(pams[5].trim());\n        }\n        return _this;\n    }\n\n    /**\r\n     * 六参数法坐标转换\r\n     * @param originX\r\n     * @param originY\r\n     * @returns {*[]}\r\n     */\n\n\n    _6PARAMS_createClass(SIX_PARAMS, [{\n        key: 'convert',\n        value: function convert(originX, originY) {\n            var x = this.a0 + this.a1 * originX + this.a2 * originY;\n            var y = this.b0 + this.b1 * originX + this.b2 * originY;\n            return [x, y];\n        }\n    }]);\n\n    return SIX_PARAMS;\n}(converttype_Base);\n\nif (!coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.SIX_PARAMS]) {\n    coordconvert_CoordConvertFactory[coordconvert_CoordConvertType.SIX_PARAMS] = SIX_PARAMS;\n}\n/* harmony default export */ var _6PARAMS = (SIX_PARAMS);\n// CONCATENATED MODULE: ./egova/coordconvert/converttype/MutilStep.js\nvar MutilStep_createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction MutilStep_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction MutilStep_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction MutilStep_inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\nvar MutilStep_MutilStep = function (_Base) {\n    MutilStep_inherits(MutilStep, _Base);\n\n    function MutilStep(steps, params) {\n        MutilStep_classCallCheck(this, MutilStep);\n\n        var _this = MutilStep_possibleConstructorReturn(this, (MutilStep.__proto__ || Object.getPrototypeOf(MutilStep)).call(this, params));\n\n        _this.convertFactorys = [];\n        var paramNum = 0;\n        for (var i in steps) {\n            var tempStep = steps[i];\n            if (tempStep.param) {\n                paramNum++;\n                _this.convertFactorys.push(new coordconvert_CoordConvertFactory[tempStep.type](arguments[paramNum]));\n            } else {\n                _this.convertFactorys.push(new coordconvert_CoordConvertFactory[tempStep.type](\"\"));\n            }\n        }\n        return _this;\n    }\n\n    MutilStep_createClass(MutilStep, [{\n        key: 'convert',\n        value: function convert(x, y) {\n            var data = arguments;\n            for (var i in this.convertFactorys) {\n                data = this.convertFactorys[i].convert.apply(this.convertFactorys[i], data);\n            }\n            return data;\n        }\n    }]);\n\n    return MutilStep;\n}(converttype_Base);\n\n/* harmony default export */ var converttype_MutilStep = (MutilStep_MutilStep);\n// CONCATENATED MODULE: ./egova/coordconvert/CoordConvert.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getConvertFactory\", function() { return getConvertFactory; });\n/* concated harmony reexport ConvertType */__webpack_require__.d(__webpack_exports__, \"ConvertType\", function() { return coordconvert_CoordConvertType; });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//\n\n\n//import './converttype/WGS84LL2GCJ02MC';\n\n//import './converttype/WGS84LL2BDMC';\n\n\n\n//import './converttype/WGS84MC2GCJ02LL';\n//import './converttype/WGS84MC2GCJ02MC';\n//import './converttype/WGS84MC2BDLL';\n//import './converttype/WGS84MC2BDMC';\n//import './converttype/WGS84MC2CITY';\n\n\n//import './converttype/GCJ02LL2WGS84MC';\n\n\n//import './converttype/GCJ02LL2BDMC';\n//import './converttype/GCJ02LL2CITY';\n\n//import './converttype/GCJ02MC2WGS84LL';\n//import './converttype/GCJ02MC2WGS84MC';\n\n//import './converttype/GCJ02MC2BDLL';\n//import './converttype/GCJ02MC2BDMC';\n//import './converttype/GCJ02MC2CITY';\n\n\n//import './converttype/BDLL2WGS84MC';\n\n//import './converttype/BDLL2GCJ02MC';\n\n//import './converttype/BDLL2CITY';\n\n//import './converttype/BDMC2WGS84LL';\n//import './converttype/BDMC2WGS84MC';\n//import './converttype/BDMC2GCJ02LL';\n//import './converttype/BDMC2GCJ02MC';\n\n//import './converttype/BDMC2CITY';\n\n\n//import './converttype/CITY2WGS84MC';\n//import './converttype/CITY2GCJ02LL';\n//import './converttype/CITY2GCJ02MC';\n//import './converttype/CITY2BDLL';\n//import './converttype/CITY2BDMC';\n\n\n\n\n\n\n/**\r\n *不转换：\"-1\"或其他值\r\n *四参数转换：wgsll2beijing54fourparam(wgs84转北京54)||wgsll2xian80fourparam(wgs84转西安80)\r\n *四参数逆转: xian80towgsllfourparam(西安80转wgs84)||beijing54towgsllfourparam(北京54转wgs84)\r\n *百度米制与经纬度: bdll2bdmc(百度经纬度转百度米制)||bdmc2bdll(百度米制转百度经纬度)\r\n *国测局与与百度: bd09togcj02(百度坐标系 (BD-09)转火星坐标系 (GCJ-02))||gcj02tobd09(火星坐标系 (GCJ-02) 转百度坐标系 (BD-09)，包括谷歌、高德转百度)\r\n *国测局与wgs84: wgs84togcj02(WGS84转GCj02)||gcj02towgs84(GCJ02转换为WGS84)\r\n *墨卡托投影与wgs84: mkt2wgs84ll(墨卡托投影(谷歌、高德)转WGS84)||wgs84ll2mkt(WGS84转墨卡托投影(谷歌、高德))\r\n *六参数转换: \r\n *七参数转换: \r\n**/\nvar list = {\n    \"84ll2bdmc\": [{ param: false, type: '84ll2bdll' }, { param: false, type: 'bdll2bdmc' }],\n    \"84ll2gcjmc\": [{ param: false, type: '84ll2gcjll' }, { param: false, type: 'gcjll2gcjmc' }],\n    \"84mc2gcjll\": [{ param: false, type: '84mc284ll' }, { param: false, type: '84ll2gcjll' }],\n    \"84mc2gcjmc\": [{ param: false, type: '84mc284ll' }, { param: false, type: '84ll2gcjll' }, { param: false, type: 'gcjll2gcjmc' }],\n    \"84mc2bdll\": [{ param: false, type: '84mc284ll' }, { param: false, type: '84ll2bdll' }],\n    \"84mc2bdmc\": [{ param: false, type: '84mc284ll' }, { param: false, type: '84ll2bdll' }, { param: false, type: 'bdll2bdmc' }],\n    \"84mc2xy\": [{ param: false, type: '84mc284ll' }, { param: true, type: '84ll2xy' }],\n    \"gcjll284mc\": [{ param: false, type: 'gcjll284ll' }, { param: false, type: '84ll284mc' }],\n    \"gcjll2bdmc\": [{ param: false, type: 'gcjll2bdll' }, { param: false, type: 'bdll2bdmc' }],\n    \"gcjll2xy\": [{ param: false, type: 'gcjll284ll' }, { param: true, type: '84ll2xy' }],\n    \"gcjmc284ll\": [{ param: false, type: 'gcjmc2gcjll' }, { param: false, type: 'gcjll284ll' }],\n    \"gcjmc284mc\": [{ param: false, type: 'gcjmc2gcjll' }, { param: false, type: 'gcjll284ll' }, { param: false, type: '84ll284mc' }],\n    \"gcjmc2bdll\": [{ param: false, type: 'gcjmc2gcjll' }, { param: false, type: 'gcjll2bdll' }],\n    \"gcjmc2bdmc\": [{ param: false, type: 'gcjmc2gcjll' }, { param: false, type: 'gcjll2bdll' }, { param: false, type: 'bdll2bdmc' }],\n    \"gcjmc2xy\": [{ param: false, type: 'gcjmc2gcjll' }, { param: false, type: 'gcjll284ll' }, { param: true, type: '84ll2xy' }],\n    \"bdll284mc\": [{ param: false, type: 'bdll284ll' }, { param: false, type: '84ll284mc' }],\n    \"bdll2gcjmc\": [{ param: false, type: 'bdll2gcjll' }, { param: false, type: 'gcjll2gcjmc' }],\n    \"bdll2xy\": [{ param: false, type: 'bdll284ll' }, { param: true, type: '84ll2xy' }],\n    \"bdmc284ll\": [{ param: false, type: 'bdmc2bdll' }, { param: false, type: 'bdll284ll' }],\n    \"bdmc284mc\": [{ param: false, type: 'bdmc2bdll' }, { param: false, type: 'bdll284ll' }, { param: false, type: '84ll284mc' }],\n    \"bdmc2gcjll\": [{ param: false, type: 'bdmc2bdll' }, { param: false, type: 'bdll2gcjll' }],\n    \"bdmc2gcjmc\": [{ param: false, type: 'bdmc2bdll' }, { param: false, type: 'bdll2gcjll' }, { param: false, type: 'gcjll2gcjmc' }],\n    \"bdmc2xy\": [{ param: false, type: 'bdmc2bdll' }, { param: false, type: 'bdll284ll' }, { param: true, type: '84ll2xy' }],\n    \"xy284mc\": [{ param: true, type: 'xy284ll' }, { param: false, type: '84ll284mc' }],\n    \"xy2gcjll\": [{ param: true, type: 'xy284ll' }, { param: false, type: '84ll2gcjll' }],\n    \"xy2gcjmc\": [{ param: true, type: 'xy284ll' }, { param: false, type: '84ll2gcjll' }, { param: false, type: 'gcjll2gcjmc' }],\n    \"xy2bdll\": [{ param: true, type: 'xy284ll' }, { param: false, type: '84ll2bdll' }],\n    \"xy2bdmc\": [{ param: true, type: 'xy284ll' }, { param: false, type: '84ll2bdll' }, { param: false, type: 'bdll2bdmc' }]\n};\nfunction getConvertFactory(type, params) {\n    var factory = null;\n    if (coordconvert_CoordConvertFactory[type]) {\n        factory = new coordconvert_CoordConvertFactory[type](params);\n    } else if (list[type]) {\n        arguments[0] = list[type];\n        factory = {};\n        factory.__proto__ = converttype_MutilStep.prototype;\n        factory.constructor.apply(factory, arguments);\n    }\n    return factory;\n}\n\n//# sourceURL=webpack://CoordConvert/./egova/coordconvert/CoordConvert.js_+_42_modules?");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

eval("var CoordConvert = __webpack_require__(/*! ./egova/coordconvert/CoordConvert */ \"./egova/coordconvert/CoordConvert.js\");\nmodule.exports = CoordConvert;\n\n//# sourceURL=webpack://CoordConvert/./index.js?");

/***/ })

/******/ });
});